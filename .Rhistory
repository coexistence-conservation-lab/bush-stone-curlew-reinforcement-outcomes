View(res_interact)
load("C:/Users/shosh/Downloads/Baboon_Data.RData")
View(Baboon_Data)
Baboon_Data[["Grooming"]]
# individual pairwise combinations
list <-combinations(n = length(residents), r = 2, v = residents, repeats.allowed = TRUE)
list1 <- list[,1]
list2 <- list[,2]
# loop through all birds to find number of points for potential interactions
exposure <- data.frame()
for(i in 1:length(list1)) {
bird1 <- filter(data_resident, id == list1[i])
bird2 <- filter(data_resident, id == list2[i])
# the start time is the later of the first timestamps
start <- max(c(min(bird1$time_local), min(bird2$time_local)))
# the end time is the earlier of the last timestamps
end <- min(c(max(bird1$time_local), max(bird2$time_local)))
# keep smaller of the number of fixes for the birds during the shared window
overlap <- data.frame(
bird1 = list1[i],
bird2 = list2[i],
overlap = as.numeric(min(
nrow(filter(bird1, time_local > start & time_local <end)),
nrow(filter(bird2, time_local > start & time_local <end)))))
exposure <- rbind(exposure, overlap)
}
View(exposure)
Baboon_Data[["Exposure"]]
# convert to wide matrix for STRAND
exposure2 <- pivot_wider(exposure, names_from = bird2, values_from = overlap) %>%
column_to_rownames(id)
# convert to wide matrix for STRAND
exposure2 <- pivot_wider(exposure, names_from = bird2, values_from = overlap) %>%
column_to_rownames("id")
?column_to_rownames
# convert to wide matrix for STRAND
exposure2 <- pivot_wider(exposure, names_from = bird2, values_from = overlap) %>%
column_to_rownames(var="id")
# convert to wide matrix for STRAND
exposure2 <- pivot_wider(exposure, names_from = bird2, values_from = overlap) %>%
column_to_rownames(bird1)
# convert to wide matrix for STRAND
exposure2 <- pivot_wider(exposure, names_from = bird2, values_from = overlap) %>%
column_to_rownames("bird1")
View(exposure2)
# convert to wide matrix for STRAND
exposure2 <- pivot_wider(exposure, names_from = bird2, values_from = overlap) %>%
column_to_rownames("bird1")
View(exposure2)
Baboon_Data[["Exposure"]]
u
# and fill in lower triangle
exposure_matrix <- as.matrix(exposure2)  # Convert to a matrix
View(exposure_matrix)
# convert to wide matrix for STRAND
exposure2 <- pivot_wider(exposure, names_from = bird2, values_from = overlap) %>%
column_to_rownames("bird1") %>%
as.matrix()
# and fill in lower triangle
exposure_matrix[lower.tri(exposure_matrix)] <- t(exposure_matrix)[lower.tri(exposure_matrix)]
View(exposure_matrix)
View(res_interact)
# interaction list
res_interact <- data_resident %>%
select(c(id, contact_id, contact)) %>%
group_by(id, contact_id) %>%
summarise(contacts = sum(contact)) %>%
na.omit() %>%
pivot_wider(names_from = contact_id, values_from = contacts, values_fill = 0)
View(res_interact)
# interaction list
res_interact <- data_resident %>%
select(c(id, contact_id, contact)) %>%
group_by(id, contact_id) %>%
summarise(contacts = sum(contact))
View(points)
View(res_interact)
# interaction list
res_interact <- data_resident %>%
select(c(id, contact_id, contact)) %>%
group_by(id, contact_id) %>%
summarise(contacts = sum(contact)) %>%
na.omit() %>%
pivot_wider(names_from = contact_id, values_from = contacts, values_fill = 0)
# interaction list
res_interact <- data_resident %>%
select(c(id, contact_id, contact)) %>%
group_by(id, contact_id) %>%
summarise(contacts = sum(contact)) %>%
na.omit()
View(res_interact)
# interaction list
res_interact <- data_resident %>%
select(c(id, contact_id, contact)) %>%
group_by(id, contact_id) %>%
summarise(contacts = sum(contact)) %>%
# remove NAs
na.omit() %>%
# add first bird to first bird comparison
rbind(data.frame("Aurora", "Aurora", 0))
View(res_interact)
View(res_interact)
# interaction list
res_interact <- data_resident %>%
select(c(id, contact_id, contact)) %>%
group_by(id, contact_id) %>%
summarise(contacts = sum(contact)) %>%
# remove NAs
na.omit() %>%
# add first bird to first bird comparison
rbind(data.frame(id = "Aurora", contact_id = "Aurora", contacts = 0))
View(res_interact)
# interaction list
res_interact <- data_resident %>%
select(c(id, contact_id, contact)) %>%
group_by(id, contact_id) %>%
summarise(contacts = sum(contact)) %>%
# remove NAs
na.omit() %>%
# add first bird to first bird comparison
rbind(data.frame(id = "Aurora", contact_id = "Aurora", contacts = 0)) %>%
# pivot to wide matrix
pivot_wider(names_from = contact_id, values_from = contacts, values_fill = 0)
View(res_interact)
?rbind
# interaction list
res_interact <- data_resident %>%
select(c(id, contact_id, contact)) %>%
group_by(id, contact_id) %>%
summarise(contacts = sum(contact)) %>%
# remove NAs
na.omit() %>%
# add first bird to first bird comparison
rbind(data.frame(id = "Aurora", contact_id = "Aurora", contacts = 0)) %>%
# pivot to wide matrix
pivot_wider(names_from = contact_id, values_from = contacts, values_fill = 0) %>%
# convert bird id to row name labels
column_to_rownames("id") %>%
# matrix
as.matrix()
View(res_interact)
View(res_interact)
# interaction list
res_interact <- data_resident %>%
select(c(id, contact_id, contact)) %>%
group_by(id, contact_id) %>%
summarise(contacts = sum(contact)) %>%
# remove NAs
na.omit() %>%
# add first bird to first bird comparison
rbind(data.frame(id = "Aurora", contact_id = "Aurora", contacts = 0)) %>%
# pivot to wide matrix
pivot_wider(names_from = contact_id, values_from = contacts, values_fill = 0) %>%
# convert bird id to row name labels
column_to_rownames("id") %>%
# move last column (from rbind) first
relocate(Aurora)
View(res_interact)
# interaction list
res_interact <- data_resident %>%
select(c(id, contact_id, contact)) %>%
group_by(id, contact_id) %>%
summarise(contacts = sum(contact)) %>%
# remove NAs
na.omit() %>%
# add first bird to first bird comparison
rbind(data.frame(id = "Aurora", contact_id = "Aurora", contacts = 0)) %>%
# pivot to wide matrix
pivot_wider(names_from = contact_id, values_from = contacts, values_fill = 0) %>%
# convert bird id to row name labels
column_to_rownames("id") %>%
# move last column (from rbind) first
relocate(Aurora) %>%
# matrix
as.matrix()
View(res_interact)
View(exposure_matrix)
# convert to wide matrix for STRAND
exposure <- pivot_wider(exposure, names_from = bird2, values_from = overlap) %>%
# convert bird id to row name labels
column_to_rownames("bird1") %>%
# matrix
as.matrix()
# and fill in lower triangle with the same pairwise values
exposure[lower.tri(exposure)] <- t(exposure)[lower.tri(exposure)]
View(exposure)
strand_res <- make_strand_data(
outcome = res_interact,
outcome_mode = "binomial",
exposure = exposure)
?make_strand_data
strand_res <- make_strand_data(
outcome = res_interact,
exposure = exposure,
outcome_mode = "binomial",
link_mode = "link_mode")
strand_res <- make_strand_data(
outcome = res_interact,
exposure = exposure,
outcome_mode = "binomial",
link_mode = "logit")
View(exposure)
strand_res <- make_strand_data(
outcome = res_interact,
exposure = exposure,
outcome_mode = "binomial",
link_mode = "logit",
check_data_organization = TRUE)
dim(res_interact)  # Check dimensions of outcome matrix
dim(exposure)      # Check dimensions of exposure matrix
rownames(res_interact)  # Check row names
colnames(res_interact)  # Check column names
rownames(exposure)      # Check row names
colnames(exposure)      # Check column names
# Check for non-numeric values
any(is.na(res_interact))  # Ensure no missing values
any(is.na(exposure))      # Ensure no missing values
strand_res <- make_strand_data(
outcome = res_interact,
exposure = exposure,
outcome_mode = "poisson",
link_mode = "logit",
check_data_organization = TRUE)
strand_res <- make_strand_data(
outcome = res_interact,
exposure = exposure,
outcome_mode = "poisson",
link_mode = "log",
check_data_organization = TRUE)
all(as.vector(exposure) > 0)
all(as.vector(res_interact) >= 0)  # Should return TRUE
all(as.vector(res_interact) %% 1 == 0)  # Should return TRUE
strand_res <- make_strand_data(
outcome = res_interact,
exposure = exposure,
outcome_mode = "poisson",
link_mode = "log"
)
str(strand_res)
# Confirm dimensions of the matrices
N_id_outcome <- nrow(res_interact)  # Number of rows in outcome matrix
N_id_exposure <- nrow(exposure)    # Number of rows in exposure matrix
# Print values
print(N_id_outcome)
print(N_id_exposure)
# Check if they match
N_id_outcome == N_id_exposure  # Should return TRUE
identical(rownames(res_interact), rownames(exposure))  # Should return TRUE
identical(colnames(res_interact), colnames(exposure))  # Should return TRUE
# Print summaries of the matrices
summary(res_interact)
summary(exposure)
# Check for unexpected values
any(is.na(res_interact))
any(is.na(exposure))
res_interact <- as.matrix(res_interact)
exposure <- as.matrix(exposure)
debug(make_strand_data)
strand_res <- make_strand_data(
outcome = res_interact,
exposure = exposure,
outcome_mode = "poisson",
link_mode = "log"
)
# Packages
pacman::p_load(adehabitatHR, amt, atlastools, beepr, ggfortify, ggmap, ggnewscale, ggpubr, ggridges, gtools, janitor, lme4, lmerTest, move2, momentuHMM, scattermore, sf, sp, STRAND, suncalc, survival, survminer, terra, tidyterra, tidyverse, wildlifeDI)
# define resident only date period
res_dates <- seq.Date(from = as_date("2023-01-16"), to = as_date("2023-06-06"), by = "day")
# subset to dates
data_resident <- data %>%
filter(date %in% res_dates)
# subset to dates
data_resident <- data %>%
dplyr::filter(date %in% res_dates)
# read in contact data
data <- read.csv("data/contact_events.csv") %>%
# Time in posix format
mutate(time_local = as.POSIXct(time_local, format = "%Y-%m-%d %H:%M:%OS",
tz = "Australia/Melbourne")) %>%
# Add date
mutate(date = as_date(time_local, tz = "Australia/Melbourne"))
# define resident only date period
res_dates <- seq.Date(from = as_date("2023-01-16"), to = as_date("2023-06-06"), by = "day")
# subset to dates
data_resident <- data %>%
filter(date %in% res_dates)
# list of residents
residents <- unique(data_resident$id)
# individual pairwise combinations
list <-combinations(n = length(residents), r = 2, v = residents, repeats.allowed = TRUE)
list1 <- list[,1]
list2 <- list[,2]
# loop through all birds to find number of points for potential interactions
exposure <- data.frame()
for(i in 1:length(list1)) {
bird1 <- filter(data_resident, id == list1[i])
bird2 <- filter(data_resident, id == list2[i])
# the start time is the later of the first timestamps
start <- max(c(min(bird1$time_local), min(bird2$time_local)))
# the end time is the earlier of the last timestamps
end <- min(c(max(bird1$time_local), max(bird2$time_local)))
# keep smaller of the number of fixes for the birds during the shared window
overlap <- data.frame(
bird1 = list1[i],
bird2 = list2[i],
overlap = as.numeric(min(
nrow(filter(bird1, time_local > start & time_local <end)),
nrow(filter(bird2, time_local > start & time_local <end)))))
exposure <- rbind(exposure, overlap)
}
# convert to wide matrix for STRAND
exposure <- pivot_wider(exposure, names_from = bird2, values_from = overlap) %>%
# convert bird id to row name labels
column_to_rownames("bird1") %>%
# matrix
as.matrix()
# and fill in lower triangle with the same pairwise values
exposure[lower.tri(exposure)] <- t(exposure)[lower.tri(exposure)]
View(exposure)
# interaction list
res_interact <- data_resident %>%
select(c(id, contact_id, contact)) %>%
group_by(id, contact_id) %>%
summarise(contacts = sum(contact)) %>%
# remove NAs
na.omit() %>%
# add first bird to first bird comparison
rbind(data.frame(id = "Aurora", contact_id = "Aurora", contacts = 0)) %>%
# pivot to wide matrix
pivot_wider(names_from = contact_id, values_from = contacts, values_fill = 0) %>%
# convert bird id to row name labels
column_to_rownames("id") %>%
# move last column (from rbind) first
relocate(Aurora) %>%
# matrix
as.matrix()
View(res_interact)
# Organize outcome & exposure measures
outcome = list(res_interact = res_interact)
View(outcome)
outcome[["res_interact"]]
exposure <- list(exposure = exposure)
View(exposure)
# make strand data object
strand_res <- make_strand_data(
outcome = res_interact,
exposure = exposure,
outcome_mode = "poisson",
link_mode = "log",
check_data_organization = TRUE)
# make strand data object
strand_res <- make_strand_data(
outcome = outcome,
exposure = exposure,
outcome_mode = "poisson",
link_mode = "log",
check_data_organization = TRUE)
outcome
exposure
identical(rownames(res_interact), rownames(exposure))  # Should return TRUE
identical(colnames(res_interact), colnames(exposure))  # Should return TRUE
View(exposure)
exposure[["exposure"]]
identical(rownames(outcome), rownames(exposure))  # Should return TRUE
identical(colnames(outcome), colnames(exposure))  # Should return TRUE
# make strand data object
strand_res <- make_strand_data(
outcome = outcome,
exposure = exposure,
outcome_mode = "poisson",
link_mode = "log",
check_data_organization = TRUE)
# make strand data object
strand_res <- make_strand_data(
outcome = outcome,
outcome_mode = "poisson",
link_mode = "log",
check_data_organization = TRUE)
load("C:/Users/shosh/Downloads/Baboon_Data.RData")
View(Baboon_Data)
Baboon_Data
View(exposure)
# Convert exposure matrix to integers
exposure <- apply(exposure, 2, as.integer)
# Convert exposure matrix to integers
exposure <- apply(exposure, as.integer)
# Convert exposure matrix to integers
exposure <- as.integer(exposure)
# convert to wide matrix for STRAND
exposure <- pivot_wider(exposure, names_from = bird2, values_from = overlap) %>%
# convert bird id to row name labels
column_to_rownames("bird1") %>%
# matrix
as.matrix()
# and fill in lower triangle with the same pairwise values
exposure[lower.tri(exposure)] <- t(exposure)[lower.tri(exposure)]
# Convert exposure matrix to integers
exposure <- as.integer(exposure)
# list of residents
residents <- unique(data_resident$id)
# individual pairwise combinations
list <-combinations(n = length(residents), r = 2, v = residents, repeats.allowed = TRUE)
list1 <- list[,1]
list2 <- list[,2]
# loop through all birds to find number of points for potential interactions
exposure <- data.frame()
# list of residents
residents <- unique(data_resident$id)
# individual pairwise combinations
list <-combinations(n = length(residents), r = 2, v = residents, repeats.allowed = TRUE)
list1 <- list[,1]
list2 <- list[,2]
# loop through all birds to find number of points for potential interactions
exposure <- data.frame()
for(i in 1:length(list1)) {
bird1 <- filter(data_resident, id == list1[i])
bird2 <- filter(data_resident, id == list2[i])
# the start time is the later of the first timestamps
start <- max(c(min(bird1$time_local), min(bird2$time_local)))
# the end time is the earlier of the last timestamps
end <- min(c(max(bird1$time_local), max(bird2$time_local)))
# keep smaller of the number of fixes for the birds during the shared window
overlap <- data.frame(
bird1 = list1[i],
bird2 = list2[i],
overlap = as.numeric(min(
nrow(filter(bird1, time_local > start & time_local <end)),
nrow(filter(bird2, time_local > start & time_local <end)))))
exposure <- rbind(exposure, overlap)
}
# convert to wide matrix for STRAND
exposure <- pivot_wider(exposure, names_from = bird2, values_from = overlap) %>%
# convert bird id to row name labels
column_to_rownames("bird1") %>%
# matrix
as.matrix()
# and fill in lower triangle with the same pairwise values
exposure[lower.tri(exposure)] <- t(exposure)[lower.tri(exposure)]
# Convert exposure matrix to integers
exposure <- as.integer(exposure)
# list of residents
residents <- unique(data_resident$id)
# individual pairwise combinations
list <-combinations(n = length(residents), r = 2, v = residents, repeats.allowed = TRUE)
list1 <- list[,1]
list2 <- list[,2]
# loop through all birds to find number of points for potential interactions
exposure <- data.frame()
for(i in 1:length(list1)) {
bird1 <- filter(data_resident, id == list1[i])
bird2 <- filter(data_resident, id == list2[i])
# the start time is the later of the first timestamps
start <- max(c(min(bird1$time_local), min(bird2$time_local)))
# the end time is the earlier of the last timestamps
end <- min(c(max(bird1$time_local), max(bird2$time_local)))
# keep smaller of the number of fixes for the birds during the shared window
overlap <- data.frame(
bird1 = list1[i],
bird2 = list2[i],
overlap = as.numeric(min(
nrow(filter(bird1, time_local > start & time_local <end)),
nrow(filter(bird2, time_local > start & time_local <end)))))
exposure <- rbind(exposure, overlap)
}
View(exposure)
# keep smaller of the number of fixes for the birds during the shared window
overlap <- data.frame(
bird1 = list1[i],
bird2 = list2[i],
overlap = as.integer(min(
nrow(filter(bird1, time_local > start & time_local <end)),
nrow(filter(bird2, time_local > start & time_local <end)))))
# loop through all birds to find number of points for potential interactions
exposure <- data.frame()
for(i in 1:length(list1)) {
bird1 <- filter(data_resident, id == list1[i])
bird2 <- filter(data_resident, id == list2[i])
# the start time is the later of the first timestamps
start <- max(c(min(bird1$time_local), min(bird2$time_local)))
# the end time is the earlier of the last timestamps
end <- min(c(max(bird1$time_local), max(bird2$time_local)))
# keep smaller of the number of fixes for the birds during the shared window
overlap <- data.frame(
bird1 = list1[i],
bird2 = list2[i],
overlap = as.integer(min(
nrow(filter(bird1, time_local > start & time_local <end)),
nrow(filter(bird2, time_local > start & time_local <end)))))
exposure <- rbind(exposure, overlap)
}
View(exposure)
# convert to wide matrix for STRAND
exposure <- pivot_wider(exposure, names_from = bird2, values_from = overlap) %>%
# convert bird id to row name labels
column_to_rownames("bird1") %>%
# matrix
as.matrix()
# and fill in lower triangle with the same pairwise values
exposure[lower.tri(exposure)] <- t(exposure)[lower.tri(exposure)]
# and fill in lower triangle with the same pairwise values
exposure[lower.tri(exposure)] <- t(exposure)[lower.tri(exposure)]
# Organize outcome & exposure measures
outcome <- list(res_interact = res_interact)
exposure <- list(exposure = exposure)
View(exposure)
# make strand data object
strand_res <- make_strand_data(
outcome = outcome,
exposure = exposure,
outcome_mode = "poisson",
link_mode = "log",
check_data_organization = TRUE)
