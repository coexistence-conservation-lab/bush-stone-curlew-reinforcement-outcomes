print(head(kud_df_utm, n= 1L))
hr90_daily <- rbind.data.frame(hr90_daily, kud_df_utm)
}}
# extract area per day i.e. drop geometry
hr90_area <- st_drop_geometry(hr_daily)
# extract area per day i.e. drop geometry
hr90_area <- st_drop_geometry(hr90_daily)
# save to file
write.csv(hr90_area, "results/daily_hr90_area.csv", row.names = TRUE)
View(hr90_area)
# social group membership
club <- c("Rowan", "Rory", "Fauna", "Zeus", "Rocky", "Sofi", "Loki", "Avery", "Maeve")
# define reinforcer date period
rein_dates <- seq.Date(from = as_date("2023-06-11"), to = as_date("2023-08-05"), by = "day")
# read in data and filter to reinforcement period
datam4 <- read.csv("results/daily_hr90_area.csv") %>%
# add metadata
left_join(dplyr::select(metadata, c("id", "cohort"))) %>%
# format dates as dates
mutate(date = as_date(date)) %>%
# limit to reinforcement period
filter(date %in% rein_dates) %>%
# add a time elapsed post-release variable
mutate(elapsed = as.numeric(date - as_date("2023-06-10"))) %>%
# add column for membership to social group
mutate(social = ifelse(id %in% club, "Reinforcer - exclusive", ifelse(cohort == "Resident", "Resident", "Reinforcer - mixed"))) %>%
# convert group to factor and set resident as the intercept
mutate(social = factor(social, levels = c("Resident", "Reinforcer - mixed", "Reinforcer - exclusive")))
# create social group means
sum4 <- datam4 %>%
group_by(date, social) %>%
summarise(dist = mean(area),
upper = dist + 1.96 * std.error(area),
lower = dist - 1.96 * std.error(area)) %>%
arrange(date)
# and overall means
mean4 <- datam4 %>%
group_by(social) %>%
summarise(mean = mean(area),
se = std.error(area))
# plot homer range size over time as social group means
ggplot(sum4, aes(date, dist, ymin = lower, ymax = upper)) +
geom_path(aes(colour = social)) +
geom_ribbon(aes(fill = social), alpha = 0.2) +
xlab("Days post-reinforcement") +
ylab("Home range 50% KUD (ha)") +
theme_minimal() +
scale_fill_viridis_d()+
scale_colour_viridis_d()
# plot homer range size over time as social group means
ggplot(sum4, aes(date, dist, ymin = lower, ymax = upper)) +
geom_path(aes(colour = social)) +
geom_ribbon(aes(fill = social), alpha = 0.2) +
xlab("Days post-reinforcement") +
ylab("Home range 90% KUD (ha)") +
theme_minimal() +
scale_fill_viridis_d()+
scale_colour_viridis_d()
# distribution of movement data
hist(datam4$area)
ggqqplot(datam4$area)
# correct left skew
hist(log1p(datam4$area))
ggqqplot(log1p(datam4$area))
# test difference between the groups with interaction of time as a quadratic
m4 <- glmmTMB(log1p(area) ~ social * (scale(elapsed) + I(scale(elapsed)^2))+ (1|id),
data = datam4,
na.action = "na.fail")
# model selection
dm4 <- dredge(m4)
dm4
View(dm4)
# parsimonious model where delta <2 and fewest predictors
# in this case there was only one model (the top ranked) with delta <2
best4 <- get.models(dm4, delta==0)[[1]]
# check model
check_model(best4)
# summary
summary(best4)
# post-hoc comparison of means
emmeans(best4, pairwise ~ social, type = "response")
# post-hoc comparison of slopes
emtrends(best4, pairwise ~ social, var = "elapsed")
# plot effects
plot_model(best4)
# marginal effects
pred4 <- predict_response(best4, terms = c("elapsed [all]", "social"))
# plot predictions
ggplot(pred4, aes(x, predicted, fill = group, ymin = conf.low, ymax = conf.high)) +
geom_line(aes(colour = group))+
geom_ribbon(alpha = 0.2)+
xlab("Days post-reinforcement") +
ylab("Predicted values of home range area (ha)") +
theme_minimal()+
scale_fill_viridis_d()+
scale_colour_viridis_d()
# read in data and filter to reinforcement period
datam1 <- read.csv("results/daily_distance_moved.csv") %>%
# add metadata
left_join(dplyr::select(metadata, c("id", "cohort"))) %>%
# format dates as dates
mutate(date = as_date(date_bird)) %>%
# limit to reinforcement period
filter(date %in% rein_dates) %>%
# add a time elapsed post-release variable
mutate(elapsed = as.numeric(date - as_date("2023-06-10"))) %>%
# add column for membership to social group
mutate(social = ifelse(id %in% club, "Reinforcer - exclusive", ifelse(cohort == "Resident", "Resident", "Reinforcer - mixed"))) %>%
# convert group to factor and set resident as the intercept
mutate(social = factor(social, levels = c("Resident", "Reinforcer - mixed", "Reinforcer - exclusive")))
# create social group means
sum1 <- datam1 %>%
group_by(date, social) %>%
summarise(dist = mean(daily_dist),
upper = dist + 1.96 * std.error(daily_dist),
lower = dist - 1.96 * std.error(daily_dist)) %>%
arrange(date)
# plot daily distance over time as social group means
ggplot(sum1, aes(date, dist, ymin = lower, ymax = upper)) +
geom_path(aes(colour = social)) +
geom_ribbon(aes(fill = social), alpha = 0.2) +
xlab("Days post-reinforcement") +
ylab("Daily distance moved (m)") +
theme_minimal() +
scale_fill_viridis_d()+
scale_colour_viridis_d()
# distribution of movement data
hist(datam1$daily_dist)
ggqqplot(datam1$daily_dist)
# test difference between the groups with interaction of time as a quadratic
m1 <- glmmTMB(daily_dist ~ social * (scale(elapsed) + I(scale(elapsed)^2)) + (1|id),
data = datam1,
na.action = "na.fail")
# model selection
dm1 <- dredge(m1)
dm1
# parsimonious model where delta <2 and fewest predictors
# in this case only one model (the top ranked) delta AICc < 2
best1 <- get.models(dm1, delta == 0)[[1]]
# check model
check_model(best1)
# summary
summary(best1)
# post-hoc comparison of slopes
emtrends(best1, pairwise ~ social, var = "elapsed")
# plot effects
plot_model(best1)
# marginal effects
pred1 <- predict_response(best1, terms = c("elapsed [all]", "social"))
# plot predictions
ggplot(pred1, aes(x, predicted, fill = group, ymin = conf.low, ymax = conf.high)) +
geom_line(aes(colour = group))+
geom_ribbon(alpha = 0.2)+
xlab("Days post-reinforcement") +
ylab("Predicted values of daily distance moved (m)") +
theme_minimal()+
scale_fill_viridis_d()+
scale_colour_viridis_d()
# read in data and filter to reinforcement period
datam2 <- read.csv("results/daily_distance_between_roosts.csv") %>%
# add metadata
left_join(dplyr::select(metadata, c("id", "cohort"))) %>%
# format dates as dates
mutate(date = as_date(date)) %>%
# limit to reinforcement period
filter(date %in% rein_dates) %>%
# add a time elapsed post-release variable and scale it
mutate(elapsed = as.numeric(date - as_date("2023-06-10"))) %>%
# add column for membership to social group
mutate(social = ifelse(id %in% club, "Reinforcer - exclusive", ifelse(cohort == "Resident", "Resident", "Reinforcer - mixed"))) %>%
# convert group to factor and set resident as the intercept
mutate(social = factor(social, levels = c("Resident", "Reinforcer - mixed", "Reinforcer - exclusive")))
# create social group means
sum2 <- datam2 %>%
group_by(date, social) %>%
summarise(dist = mean(distance_previous),
upper = dist + 1.96 * std.error(distance_previous),
lower = dist - 1.96 * std.error(distance_previous)) %>%
arrange(date)
# plot roost displacement over time as social group means
ggplot(sum2, aes(date, dist, ymin = lower, ymax = upper)) +
geom_path(aes(colour = social)) +
geom_ribbon(aes(fill = social), alpha = 0.2) +
xlab("Days post-reinforcement") +
ylab("Distance between consecutive roosts (m)") +
theme_minimal() +
scale_fill_viridis_d()+
scale_colour_viridis_d()
# distribution of movement data
hist(datam2$distance_previous)
ggqqplot(datam2$distance_previous)
# correct left skew
hist(log1p(datam2$distance_previous))
ggqqplot(log1p(datam2$distance_previous))
# test difference between the groups with interaction of time as a quadratic
m2 <- glmmTMB(log1p(distance_previous) ~ social * (scale(elapsed) + I(scale(elapsed)^2)) + (1|id),
data = datam2,
na.action = "na.fail")
# model selection
dm2 <- dredge(m2)
dm2
# parsimonious model where delta <2 and fewest predictors
#  in this case only one model (the top ranked) delta AICc < 2
best2 <- get.models(dm2, delta == 0)[[1]]
# check model
check_model(best2)
# summary
summary(best2)
# plot effects
plot_model(best2)
# marginal effects
pred2 <- predict_response(best2, terms = c("elapsed [all]", "social"))
# plot predictions
ggplot(pred2, aes(x, predicted, fill = group, ymin = conf.low, ymax = conf.high)) +
geom_line(aes(colour = group))+
geom_ribbon(alpha = 0.2)+
xlab("Days post-reinforcement") +
ylab("Predicted values of roost displacement (m)") +
theme_minimal()+
scale_fill_viridis_d()+
scale_colour_viridis_d()
# read in data and filter to reinforcement period
datam3 <- read.csv("results/daily_roost_distance_from_release.csv") %>%
# add metadata
left_join(dplyr::select(metadata, c("id", "cohort"))) %>%
# format dates as dates
mutate(date = as_date(date)) %>%
# limit to reinforcement period
filter(date %in% rein_dates) %>%
# add a time elapsed post-release variable
mutate(elapsed = as.numeric(date - as_date("2023-06-10"))) %>%
# add column for membership to social group
mutate(social = ifelse(id %in% club, "Reinforcer - exclusive", ifelse(cohort == "Resident", "Resident", "Reinforcer - mixed"))) %>%
# convert group to factor and set resident as the intercept
mutate(social = factor(social, levels = c("Resident", "Reinforcer - mixed", "Reinforcer - exclusive")))
# create social group means
sum3 <- datam3 %>%
group_by(date, social) %>%
summarise(dist = mean(dist_release),
upper = dist + 1.96 * std.error(dist_release),
lower = dist - 1.96 * std.error(dist_release)) %>%
arrange(date)
# plot distance from release site over time as social group means
ggplot(sum3, aes(date, dist, ymin = lower, ymax = upper)) +
geom_path(aes(colour = social)) +
geom_ribbon(aes(fill = social), alpha = 0.2) +
xlab("Days post-reinforcement") +
ylab("Distance from release site (m)") +
theme_minimal() +
scale_fill_viridis_d()+
scale_colour_viridis_d()
# distribution of movement data
hist(datam3$dist_release)
ggqqplot(datam3$dist_release)
# correct left skew - still not great but a bit better
hist(sqrt(datam3$dist_release))
ggqqplot(sqrt(datam3$dist_release))
# test difference between the groups with interaction of time as a quadratic
m3 <- glmmTMB(sqrt(dist_release) ~ social * (scale(elapsed) + I(scale(elapsed)^2)) + (1|id),
data = datam3,
na.action = "na.fail")
# model selection
dm3 <- dredge(m3)
dm3
# parsimonious model where delta <2 and fewest predictors
# in this case there was only one model (the top ranked) with delta <2
best3 <- get.models(dm3, delta ==0)[[1]]
# check model
check_model(best3)
# summary
summary(best3)
# post-hoc comparison of means
emmeans(best3, pairwise ~ social, type = "response")
# post-hoc comparison of slopes
emtrends(best3, pairwise ~ social, var = "elapsed")
# plot effects
plot_model(best3)
# marginal effects
pred3 <- predict_response(best3, terms = c("elapsed [all]", "social"))
# plot predictions
ggplot(pred3, aes(x, predicted, fill = group, ymin = conf.low, ymax = conf.high)) +
geom_line(aes(colour = group))+
geom_ribbon(alpha = 0.2)+
xlab("Days post-reinforcement") +
ylab("Predicted values of distance from release site (m)") +
theme_minimal()+
scale_fill_viridis_d()+
scale_colour_viridis_d()
# read in data and filter to reinforcement period
datam5 <- read.csv("results/daily_time_budget.csv") %>%
# add metadata
left_join(dplyr::select(metadata, c("id", "cohort"))) %>%
# format dates as dates
mutate(date = as_date(date_bird)) %>%
# limit to reinforcement period
filter(date %in% rein_dates) %>%
# add a time elapsed post-release variable
mutate(elapsed = as.numeric(date - as_date("2023-06-10"))) %>%
# add column for membership to social group
mutate(social = ifelse(id %in% club, "Reinforcer - exclusive", ifelse(cohort == "Resident", "Resident", "Reinforcer - mixed"))) %>%
# convert group to factor and set resident as the intercept
mutate(social = factor(social, levels = c("Resident", "Reinforcer - mixed", "Reinforcer - exclusive")))
# create social group means
sum5 <- datam5 %>%
group_by(date, social) %>%
summarise(dist = mean(state2p),
upper = dist + 1.96 * std.error(state2p),
lower = dist - 1.96 * std.error(state2p)) %>%
arrange(date)
# overall means
mean5 <- datam5 %>%
group_by(social) %>%
summarise(mean = mean(state2p),
se = std.error(state2p))
# and pivot longer for barchart
datam5bar <- datam5 %>%
select(!3:7) %>%
pivot_longer(3:6, names_to = "state", values_to = "proportion")
# plot time budget by social group
ggplot(datam5bar)+
geom_bar(aes(x = social, y = proportion, fill = state),
position="fill", stat="identity")+
xlab("Social group")+
ylab("Time budget allocation")+
theme_minimal()+
scale_fill_viridis_d()
# plot foraging allocation over time as social group means
ggplot(sum5, aes(date, dist, ymin = lower, ymax = upper)) +
geom_path(aes(colour = social)) +
geom_ribbon(aes(fill = social), alpha = 0.2) +
xlab("Days post-reinforcement") +
ylab("Proportion time allocated to foraging %") +
theme_minimal() +
scale_fill_viridis_d()+
scale_colour_viridis_d()
# distribution of allocation
hist(datam5$state2p)
ggqqplot(datam5$state2p)
# Adjust values slightly so that 0 < x < 1
datam5 <- datam5 %>%
mutate(adjusted = (state2p + 0.001) / 1.002)
hist(datam5$adjusted)
ggqqplot(datam5$adjusted)
# test difference between the groups with interaction of time as a quadratic
m5 <- glmmTMB(adjusted ~ social * (scale(elapsed) + I(scale(elapsed)^2)) + (1|id),
data = datam5,
family = beta_family(link = "logit"),
na.action = "na.fail")
# model selection
dm5 <- dredge(m5)
dm5
# parsimonious model where delta <2 and fewest predictors
# in this case the second model had delta AICc of 1 and 2 fewer predictors
best5 <- get.models(dm5, delta<2)[[2]]
# check model
check_model(best5)
# summary
summary(best5)
# post-hoc comparison of means
emmeans(best5, pairwise ~ social, type = "response")
# post-hoc comparison of slopes
emtrends(best5, pairwise ~ social, var = "elapsed")
# plot effects
plot_model(best5)
# marginal effects
pred5 <- predict_response(best5, terms = c("elapsed [all]", "social"),
bias_correction = TRUE)
# plot predictions
ggplot(pred5, aes(x, predicted, fill = group, ymin = conf.low, ymax = conf.high)) +
geom_line(aes(colour = group))+
geom_ribbon(alpha = 0.2)+
xlab("Days post-reinforcement") +
ylab("Predicted values of time allocated to foraging %") +
theme_minimal()+
scale_fill_viridis_d()+
scale_colour_viridis_d()
# read in data and clean up
datam6 <- read_xlsx("data/healthchecks.xlsx") %>%
clean_names() %>%
rename(id = identity) %>%
select(id, date, weight) %>%
# add metadata
left_join(select(metadata, c(id, start_date, cohort))) %>%
drop_na() %>%
# format dates
mutate(date = as_date(date),
start_date = as_date(start_date)) %>%
# calculate elapsed time and add status
mutate(elapsed = as.numeric(date - start_date)) %>%
# keep only reinforcers
filter(cohort == "Reinforcing") %>%
# add social group membership %>%
mutate(social = as_factor(ifelse(id %in% club, "Reinforcer - exclusive", ifelse(cohort == "Resident", "Resident", "Reinforcer - mixed")))) %>%
# keep only the latest pre-release values and assign to pre/post release
group_by(id) %>%
filter(elapsed > 0 | elapsed == max(elapsed[elapsed <= 0])) %>%
ungroup() %>%
mutate(status = as_factor(ifelse(elapsed > 0, "post-release", "pre-release"))) %>%
arrange(id) %>%
# filter to study period
filter(elapsed <70)
# plot weight pre and post-release
ggplot(datam6)+
geom_boxplot(aes(social, weight))+
theme_minimal()+
facet_wrap(~status)
# check distribution of the difference
hist(sum6$diff)
# check distribution of the difference
hist(sum6$diff)
# calculate weight change in grams and as a proportion of starting weight
sum6 <- datam6 %>%
select(c(id, social, weight, status)) %>%
pivot_wider(names_from = status, values_from = weight) %>%
clean_names() %>%
drop_na() %>%
# add change columns
mutate(diff = pre_release - post_release,
proportion = diff/pre_release) %>%
# format social group as factor
mutate(social = as_factor(social))
# plot total weight differences by social group
ggplot(sum6)+
geom_boxplot(aes(social, diff))+
theme_minimal()
# plot proportional weight differences by social group
ggplot(sum6)+
geom_boxplot(aes(social, proportion))+
theme_minimal()
# check distribution of the difference
hist(sum6$diff)
ggqqplot(sum6$diff)
# test whether weight change differs between the social groups
# as total difference
m6a <- glmmTMB(diff ~ social, data = sum6)
summary(m6a)
# and as a proportion of starting weight
m6b <- glmmTMB(proportion ~ social, data = sum6)
summary(m6b)
# predictions
pred6b <- predict_response(m6b, terms = c("social"))
# plot predictions
ggplot(pred6b, aes(x, predicted, colour = x))+
geom_pointrange(aes(ymin = conf.low, ymax = conf.high))+
xlab("Social group membership") +
ylab("Predicted values of proportion starting weight lost")+
theme_classic()+
scale_y_continuous(limits = c(0, 0.3))
# weight change over time between social groups
m6 <- glmmTMB(weight ~ social * status, data = datam6)
summary(m6)
# predictions
pred6 <- predict_response(m6, terms = c("status", "social"))
# plot predictions
ggplot(pred6, aes(x, predicted, fill = group, ymin = conf.low, ymax = conf.high, group = group)) +
geom_line(aes(colour = group))+
geom_ribbon(alpha = 0.2)+
xlab(element_blank())+
ylab("Predicted weight (g)") +
theme_minimal()
# set default theme options for all plots
pal <- c("#AFACAC","#2E3EDC", "#07A567")
theme <- function(){
list(
geom_line(aes(colour = group)),
geom_ribbon(alpha = 0.2),
xlab(element_blank()),
scale_x_continuous(breaks=seq(0, 50, 10)),
theme_classic(),
ggplot2::theme(axis.title.y = element_text(hjust = 0.1, size = 10)),
scale_color_manual(values = pal,
name = "Cohort and social group membership"),
scale_fill_manual(values = pal,,
name = "Cohort and social group membership")
)
}
# list of plots
g1 <- ggplot(pred1, aes(x, predicted, fill = group, ymin = conf.low, ymax = conf.high)) +
xlab("Days post-reinforcement") +
ylab("Daily distance moved (m)")+
theme()
g2 <- ggplot(pred2, aes(x, predicted, fill = group, ymin = conf.low, ymax = conf.high)) +
xlab("Days post-reinforcement") +
ylab("Roost displacement (m)")+
theme()
g3 <- ggplot(pred3, aes(x, predicted, fill = group, ymin = conf.low, ymax = conf.high)) +
xlab("Days post-reinforcement") +
ylab("Distance from release (m)")+
theme()
g4 <- ggplot(pred4, aes(x, predicted, fill = group, ymin = conf.low, ymax = conf.high)) +
xlab("Days post-reinforcement") +
ylab("Home range area (ha)")+
theme()
g5 <- ggplot(pred5, aes(x, predicted, fill = group, ymin = conf.low, ymax = conf.high)) +
xlab("Days post-reinforcement") +
ylab("Time allocated to foraging")+
theme()
g6 <- ggplot(pred6, aes(x, predicted, fill = group,
ymin = conf.low, ymax = conf.high, group = group)) +
geom_line(aes(colour = group))+
geom_ribbon(alpha = 0.2)+
theme_classic()+
xlab(element_blank())+
ylab("Weight (g)") +
scale_colour_manual(values = c("#2E3EDC", "#07A567"))+
scale_fill_manual(values = c("#2E3EDC", "#07A567"))+
ggplot2::theme(axis.title.y = element_text(hjust = 0.3, size = 10))
# multi plot 3x2
ggarrange(g1, g2, g3, g4, g5, g6,
ncol = 3, nrow = 2,
labels = c("A", "B", "C", "D", "E", "F"),
common.legend = TRUE, legend = "bottom")
