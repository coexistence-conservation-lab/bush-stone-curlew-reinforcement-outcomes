n1 <- ggraph(comm1)+
# community polygon
geom_mark_hull(aes(x = x, y = y, fill = community),
colour = "white", alpha = 0.2, expand = unit(0.5, "cm"),
show.legend = FALSE)+
scale_fill_manual(values = c("grey10", "grey60"))+
# format edge colour, alpha and width by the weight (proximity)
geom_edge_fan(aes(colour = weight, alpha = weight, linewidth = weight/2),
show.legend = FALSE)+
scale_edge_color_continuous(low = "grey", high = "slateblue4")+
# node basic
geom_node_point(size = 5, shape = 16)+
# theme
expand_limits(x = c(-6, 3), y = c(-4.5, 0.4))+
theme_graph(foreground = "black", border = TRUE,
plot_margin = margin(10, 60, 0, 60))
# resident network
n1 <- ggraph(comm1)+
# community polygon
geom_mark_hull(aes(x = x, y = y, fill = community),
colour = "white", alpha = 0.2, expand = unit(0.5, "cm"),
show.legend = FALSE)+
scale_fill_manual(values = c("grey10", "grey60"))+
# format edge colour, alpha and width by the weight (proximity)
geom_edge_fan(aes(colour = weight, alpha = weight, linewidth = weight/2),
show.legend = FALSE)+
scale_edge_color_continuous(low = "grey", high = "slateblue4")+
# node basic
geom_node_point(size = 5, shape = 16)+
# theme
expand_limits(x = c(-6, 3), y = c(-4.5, 0.4))+
theme_graph(foreground = "black", border = TRUE,
plot_margin = margin(10, 60, 0, 60))
# reinforcer network
n2 <- ggraph(comm2)+
# communites polygons
geom_mark_hull(aes(x = x, y = y, fill = community),
colour = "white", alpha = 0.2, expand = unit(0.8, "cm"),
show.legend = FALSE)+
scale_fill_manual(values = c("seagreen3", "#2E3FFF"))+
# format edge colour, alpha and width by the weight (proximity)
geom_edge_fan(aes(colour = weight, alpha = weight, width = weight),
show.legend = FALSE)+
scale_edge_color_continuous(low = "grey90", high = "slateblue4")+
scale_edge_width(range = c(0.1, 3))+
# node shape by cohort
geom_node_point(aes(shape = cohort), size = 5,
show.legend = FALSE)+
scale_shape_manual(values=c(15, 16))+
# theme
expand_limits(x = c(2, 7), y = c(-3.8, 2.6))+
theme_graph(foreground = "black", border = TRUE,
plot_margin = margin(10, 20, 20, 20))
# multi panel
ggarrange(n1, n2,
labels = c("A", "B"),
ncol = 1, nrow = 2,
heights = c(0.5, 1))
ggmap(map_z15)+
# plot roosts colour by time
geom_point(aes(longitude, latitude, colour = date),
size = 2, data = datam8, inherit.aes = FALSE)+
# add release location
geom_point(aes(144.434323, -37.902374),
colour = "white", size = 5, shape = 13, inherit.aes = FALSE)+
# add fence
geom_spatvector(data = mtr, inherit.aes = FALSE, fill = NA, colour = "white",
linetype = "longdash")+
# wrap by period
facet_wrap(~period)+
# theme options
scale_colour_viridis_c(trans = "date", name = "2023")+
theme_void()+
scale_y_continuous(expand = expansion(mult = c(0, 0.01)))+
theme(legend.position="bottom",
legend.key.width = unit(4, 'cm'),
strip.text = element_text(size = 15))
ggmap(map_z15)+
# plot roosts colour by time
geom_point(aes(longitude, latitude, colour = date, shape = id),
size = 2, data = datam8, inherit.aes = FALSE)+
# add release location
geom_point(aes(144.434323, -37.902374),
colour = "white", size = 5, shape = 13, inherit.aes = FALSE)+
# add fence
geom_spatvector(data = mtr, inherit.aes = FALSE, fill = NA, colour = "white",
linetype = "longdash")+
# wrap by period
facet_wrap(~period)+
# theme options
scale_colour_viridis_c(trans = "date", name = "2023")+
theme_void()+
scale_y_continuous(expand = expansion(mult = c(0, 0.01)))+
theme(legend.position="bottom",
legend.key.width = unit(4, 'cm'),
strip.text = element_text(size = 15))
ggmap(map_z15)+
# plot roosts colour by time
geom_point(aes(longitude, latitude, colour = date, shape = id),
size = 2, data = datam8, inherit.aes = FALSE)+
# add release location
geom_point(aes(144.434323, -37.902374),
colour = "white", size = 5, shape = 13, inherit.aes = FALSE)+
# add fence
geom_spatvector(data = mtr, inherit.aes = FALSE, fill = NA, colour = "white",
linetype = "longdash")+
# wrap by period
facet_wrap(~period)+
# theme options
scale_colour_viridis_c(trans = "date", name = "2023")+
theme_void()+
scale_y_continuous(expand = expansion(mult = c(0, 0.01)))
# read in data and filter to reinforcement period
datam1 <- read.csv("results/daily_distance_moved.csv") %>%
# add metadata
left_join(dplyr::select(metadata, c("id", "cohort"))) %>%
# format dates as dates
mutate(date = as_date(date_bird)) %>%
# add a time elapsed post-release variable
mutate(elapsed = date - as_date("2023-06-11")) %>%
# add column for membership to social group
mutate(social = ifelse(id %in% club, "Reinforcer - exclusive", ifelse(cohort == "Resident", "Resident", "Reinforcer - mixed"))) %>%
# limit to reinforcement period
filter(date %in% rein_dates)
# Packages
pacman::p_load(adehabitatHR, amt, atlastools, beepr, emmeans, ggfortify, ggmap, ggnewscale, ggforce, ggpubr, ggraph, ggridges, ggspatial, glmmTMB, gtools, igraph, janitor, jtools, lme4, lmerTest, move2, momentuHMM, readxl, scales, scattermore, sf, sp, suncalc, survival, survminer, terra, tidygraph, tidyterra, tidyverse, viridis, wildlifeDI)
# Metadata - translocation information
metadata  <- read.csv("data/metadata.csv") %>%
clean_names() %>%
rename(id = identity,
mortality = mortality_or_capture) %>%
mutate(start_date = as_date(dmy(start_date)),
end_date = as_date(dmy(end_date)),
mortality = as_date(dmy(mortality)))
# read in data and filter to reinforcement period
datam1 <- read.csv("results/daily_distance_moved.csv") %>%
# add metadata
left_join(dplyr::select(metadata, c("id", "cohort"))) %>%
# format dates as dates
mutate(date = as_date(date_bird)) %>%
# add a time elapsed post-release variable
mutate(elapsed = date - as_date("2023-06-11")) %>%
# add column for membership to social group
mutate(social = ifelse(id %in% club, "Reinforcer - exclusive", ifelse(cohort == "Resident", "Resident", "Reinforcer - mixed"))) %>%
# limit to reinforcement period
filter(date %in% rein_dates)
# create social group means
sum1 <- datam1 %>%
group_by(date, social) %>%
summarise(daily_dist = mean(daily_dist)) %>%
arrange(date)
# plot daily distance by social group
ggplot(datam1)+
geom_boxplot(aes(social,daily_dist))+
theme_minimal()+
xlab("Social group") +
ylab("Daily distance moved (m)")+
theme_minimal()
# plot daily distance over time as social group means
ggplot(sum1)+
geom_path(aes(date, daily_dist, color = social), linewidth = 1)+
theme_minimal() +
xlab("Days post-release") +
ylab("Daily distance moved (m)")+
theme_minimal()+
scale_colour_manual(values = c("#440154", "#F08080", "#FFD700"))
# plot daily distance over time as linear model
ggplot(datam1)+
geom_smooth(aes(elapsed, daily_dist, color = social), method = "lm")+
theme_minimal() +
xlab("Days post-release") +
ylab("Daily distance moved (m)")+
scale_colour_manual(values = c("#440154", "#F08080", "#FFD700"))
# distribution of movement data
hist(datam1$daily_dist)
ggqqplot(datam1$daily_dist)
# test difference between the groups with interaction of time
m1 <- lmer(daily_dist ~ social * scale(date) + I(scale(date))^2+ (1|id), data = datam1)
summary(m1)
# test difference between the groups with interaction of time
m1 <- lmer(daily_dist ~ social * (scale(date) + I(scale(date)^2))+ (1|id),
data = datam1)
summary(m1)
# Packages
pacman::p_load(adehabitatHR, amt, atlastools, beepr, emmeans, ggfortify, ggmap, ggnewscale, ggforce, ggpubr, ggraph, ggridges, ggspatial, glmmTMB, gtools, igraph, janitor, jtools, lme4, lmerTest, move2, momentuHMM, readxl, scales, scattermore, sf, sjPlot, sp, suncalc, survival, survminer, terra, tidygraph, tidyterra, tidyverse, viridis, wildlifeDI)
plot_model(m1)
plot_model(m1, type = "pred")
?plot_model
plot_model(m1, type = "int")
sjPlot::plot_model(m1, type = "int")
# Packages
pacman::p_load(adehabitatHR, amt, atlastools, beepr, effects, emmeans, ggfortify, ggmap, ggnewscale, ggforce, ggpubr, ggraph, ggridges, ggspatial, glmmTMB, gtools, igraph, janitor, jtools, lme4, lmerTest, move2, momentuHMM, readxl, scales, scattermore, sf, sjPlot, sp, suncalc, survival, survminer, terra, tidygraph, tidyterra, tidyverse, viridis, wildlifeDI)
# Packages
pacman::p_load(adehabitatHR, amt, atlastools, beepr, effects, emmeans, ggfortify, ggmap, ggnewscale, ggforce, ggpubr, ggraph, ggridges, ggspatial, glmmTMB, gtools, igraph, janitor, jtools, lme4, lmerTest, move2, momentuHMM, readxl, scales, scattermore, sf, sjPlot, sp, suncalc, survival, survminer, terra, tidygraph, tidyterra, tidyverse, viridis, wildlifeDI)
plot(allEffects(m1))
# test difference between the groups with interaction of time
m1 <- glmmTMB(daily_dist ~ social * (scale(date) + I(scale(date)^2))+ (1|id),
data = datam1)
plot(allEffects(m1))
# test difference between the groups with interaction of time
m1 <- glmmTMB(daily_dist ~ social * (scale(elapsed) + I(scale(date)^2))+ (1|id),
data = datam1)
# test difference between the groups with interaction of time
m1 <- glmmTMB(daily_dist ~ social * (scale(elapsed) + I(scale(elapsed)^2))+ (1|id),
data = datam1)
plot(allEffects(m1))
View(datam1)
# read in data and filter to reinforcement period
datam1 <- read.csv("results/daily_distance_moved.csv") %>%
# add metadata
left_join(dplyr::select(metadata, c("id", "cohort"))) %>%
# format dates as dates
mutate(date = as_date(date_bird)) %>%
# add a time elapsed post-release variable
mutate(elapsed = as.numeric(date - as_date("2023-06-11"))) %>%
# add column for membership to social group
mutate(social = ifelse(id %in% club, "Reinforcer - exclusive", ifelse(cohort == "Resident", "Resident", "Reinforcer - mixed"))) %>%
# limit to reinforcement period
filter(date %in% rein_dates)
View(datam1)
# test difference between the groups with interaction of time
m1 <- glmmTMB(daily_dist ~ social * (scale(elapsed) + I(scale(elapsed)^2))+ (1|id),
data = datam1)
plot(allEffects(m1))
plot_model(m1, type = "int")
plot_model(m1)
summary(m1)
# read in data and filter to reinforcement period
datam2 <- read.csv("results/daily_distance_between_roosts.csv") %>%
# add metadata
left_join(dplyr::select(metadata, c("id", "cohort"))) %>%
# format dates as dates
mutate(date = as_date(date)) %>%
# add a time elapsed post-release variable
mutate(elapsed = date - as_date("2023-06-11")) %>%
# add column for membership to social group
mutate(social = ifelse(id %in% club, "Reinforcer - exclusive", ifelse(cohort == "Resident", "Resident", "Reinforcer - mixed"))) %>%
# limit to reinforcement period
filter(date %in% rein_dates)
# create cohort means
sum2 <- datam2 %>%
group_by(date, social) %>%
summarise(distance_previous = mean(distance_previous)) %>%
arrange(date)
# plot daily roost distance by social group
ggplot(datam2)+
geom_boxplot(aes(social,distance_previous))+
theme_minimal()+
xlab("Social group") +
ylab("Daily distance between roosts (m)")
# plot daily roost distance over time as social group means
ggplot(sum2)+
geom_path(aes(date, distance_previous, color = social), linewidth = 1)+
theme_minimal() +
xlab("Date") +
ylab("Daily distance between roosts (m)")+
scale_colour_manual(values = c("#440154", "#F08080", "#FFD700"))
# plot daily roost distance over time as linear model
ggplot(datam2)+
geom_smooth(aes(elapsed, distance_previous, color = social), method = "lm")+
theme_minimal() +
xlab("Days post-release") +
ylab("Daily distance between roosts (m)")+
scale_colour_viridis_d()+
scale_colour_manual(values = c("#440154", "#F08080", "#FFD700"))
# test whether establishment differs between the groups
m2 <- lmer(log(distance_previous) ~ social * scale(date) + (1|id), data = datam2)
summary(m2)
# test whether establishment differs between the groups
m2 <- glmmTMB(log(distance_previous) ~ social * scale(date) + (1|id), data = datam2)
plot_model(m2)
plot_model(m2, type = "pred")
# distribution of movement data
hist(datam2$distance_previous)
# distribution of movement data
hist(datam2$distance_previous)
# correct left skew
hist(log(datam2$distance_previous))
View(datam2)
# correct left skew
hist(log1p(datam2$distance_previous))
# test whether establishment differs between the groups
m2 <- glmmTMB(log1p(distance_previous) ~ social * scale(date) + (1|id), data = datam2)
plot_model(m2, type = "pred")
plot_model(m2)
# plot daily distance over time as social group means
ggplot(sum1)+
geom_path(aes(date, daily_dist, color = social), linewidth = 1)+
xlab("Days post-release")+
ylab("Daily distance moved (m)")+
theme_minimal()
# plot daily distance by social group
ggplot(datam1)+
geom_boxplot(aes(social,daily_dist))+
xlab("Social group")+
ylab("Daily distance moved (m)")+
theme_minimal()
# distribution of movement data
hist(datam1$daily_dist)
ggqqplot(datam1$daily_dist)
# test difference between the groups with interaction of time as a quadratic
m1 <- glmmTMB(daily_dist ~ social * (scale(elapsed) + I(scale(elapsed)^2))+ (1|id), data = datam1)
summary(m1)
# read in data and filter to reinforcement period
datam1 <- read.csv("results/daily_distance_moved.csv") %>%
# add metadata
left_join(dplyr::select(metadata, c("id", "cohort"))) %>%
# format dates as dates
mutate(date = as_date(date_bird)) %>%
# limit to reinforcement period
filter(date %in% rein_dates) %>%
# add a time elapsed post-release variable
mutate(elapsed = as.numeric(date - as_date("2023-06-11"))) %>%
# add column for membership to social group
mutate(social = ifelse(id %in% club, "Reinforcer - exclusive", ifelse(cohort == "Resident", "Resident", "Reinforcer - mixed"))) %>%
# convert group to factor and set resident as the intercept
mutate(social = factor(social, levels = c("Resident", "Reinforcer - mixed", "Reinforcer - exclusive")))
# test difference between the groups with interaction of time as a quadratic
m1 <- glmmTMB(daily_dist ~ social * (scale(elapsed) + I(scale(elapsed)^2))+ (1|id), data = datam1)
summary(m1)
plot_model(m1)
# model selection
dredge(m1)
# Packages
pacman::p_load(adehabitatHR, amt, atlastools, beepr, effects, emmeans, ggfortify, ggmap, ggnewscale, ggforce, ggpubr, ggraph, ggridges, ggspatial, glmmTMB, gtools, igraph, janitor, jtools, lme4, lmerTest, move2, momentuHMM, MuMIn, readxl, scales, scattermore, sf, sjPlot, sp, suncalc, survival, survminer, terra, tidygraph, tidyterra, tidyverse, viridis, wildlifeDI)
# model selection
dredge(m1)
View(m1)
options(na.action = "na.fail")
# model selection
dredge(m1)
# models with AIC =< best model
best <- subset(dredge(m1), delta <= 2, recalc.weights=FALSE)
best
# model selection
dredge(m1)
# model selection
dm1 <- dredge(m1)
View(dm1)
dm1[1,]
# print best model on AICc
subset(dm1, delta ==0)
# print best model on AICc
best1 <- get.models(dm1, delta==0)
best1
summary(best1)
# print best model on AICc
best1 <- get.models(dm1, delta==0)[[1]]
summary(best1)
# check residuals
hist(residuals(best1))
ggqqplot(residuals(best1))
# plot effects
plot_model(best1)
# post-hoc tukey
emmeans(best1, pairwise ~ social, adjust = "tukey", type = "response")
# post-hoc tukey
emmeans(best1, pairwise ~ social, adjust = "tukey")
# post-hoc tukey
emmeans(best1, adjust = "tukey", type = "response")
# post-hoc tukey
emmeans(best1, pairwise ~ social, type = "response")
# plot predictions
plot_model(best1, type = "pred")
# plot predictions
sjPlot::plot_model(best1, type = "pred")
# Packages
pacman::p_load(adehabitatHR, amt, atlastools, beepr, effects, emmeans, ggfortify, ggmap, ggnewscale, ggforce, ggpubr, ggraph, ggridges, ggspatial, glmmTMB, gtools, igraph, janitor, jtools, lme4, lmerTest, move2, momentuHMM, MuMIn, readxl, scales, scattermore, sf, sjPlot, sp, suncalc, survival, survminer, terra, tidygraph, tidyterra, tidyverse, viridis, wildlifeDI)
# Metadata - translocation information
metadata  <- read.csv("data/metadata.csv") %>%
clean_names() %>%
rename(id = identity,
mortality = mortality_or_capture) %>%
mutate(start_date = as_date(dmy(start_date)),
end_date = as_date(dmy(end_date)),
mortality = as_date(dmy(mortality)))
# read in data and filter to reinforcement period
datam1 <- read.csv("results/daily_distance_moved.csv") %>%
# add metadata
left_join(dplyr::select(metadata, c("id", "cohort"))) %>%
# format dates as dates
mutate(date = as_date(date_bird)) %>%
# limit to reinforcement period
filter(date %in% rein_dates) %>%
# add a time elapsed post-release variable
mutate(elapsed = as.numeric(date - as_date("2023-06-11"))) %>%
# add column for membership to social group
mutate(social = ifelse(id %in% club, "Reinforcer - exclusive", ifelse(cohort == "Resident", "Resident", "Reinforcer - mixed"))) %>%
# convert group to factor and set resident as the intercept
mutate(social = factor(social, levels = c("Resident", "Reinforcer - mixed", "Reinforcer - exclusive")))
# social group membership
club <- c("Rowan", "Rory", "Fauna", "Zeus", "Rocky", "Sofi", "Loki", "Avery", "Maeve")
# define reinforcer date period
rein_dates <- seq.Date(from = as_date("2023-06-11"), to = as_date("2023-08-05"), by = "day")
# read in data and filter to reinforcement period
datam1 <- read.csv("results/daily_distance_moved.csv") %>%
# add metadata
left_join(dplyr::select(metadata, c("id", "cohort"))) %>%
# format dates as dates
mutate(date = as_date(date_bird)) %>%
# limit to reinforcement period
filter(date %in% rein_dates) %>%
# add a time elapsed post-release variable
mutate(elapsed = as.numeric(date - as_date("2023-06-11"))) %>%
# add column for membership to social group
mutate(social = ifelse(id %in% club, "Reinforcer - exclusive", ifelse(cohort == "Resident", "Resident", "Reinforcer - mixed"))) %>%
# convert group to factor and set resident as the intercept
mutate(social = factor(social, levels = c("Resident", "Reinforcer - mixed", "Reinforcer - exclusive")))
# test difference between the groups with interaction of time as a quadratic
m1 <- glmmTMB(daily_dist ~ social * (scale(elapsed) + I(scale(elapsed)^2))+ (1|id),
data = datam1)
summary(m1)
# model selection
dm1 <- dredge(m1)
# test difference between the groups with interaction of time as a quadratic
m1 <- glmmTMB(daily_dist ~ social * (scale(elapsed) + I(scale(elapsed)^2))+ (1|id),
data = datam1,
na.action = "na.fail")
# model selection
dm1 <- dredge(m1)
# print best model on AICc
best1 <- get.models(dm1, delta==0)[[1]]
summary(best1)
# plot predictions
sjPlot::plot_model(best1, type = "pred")
# plot predictions
sjPlot::plot_model(best1, type = "pred", terms = "social")
# plot predictions
sjPlot::plot_model(best1, type = "simulate")
# plot predictions
sjPlot::plot_model(best1, type = "emm")
# plot predictions
sjPlot::plot_model(best1, type = pred)
# plot predictions
sjPlot::plot_model(best1, type = "pred")
# plot predictions
ggeffects::predict_response(best1)
# plot predictions
ggeffects::predict_response(best1, se.fit = FALSE)
# plot predictions
ggeffects::predict_response(best1, se.fit = FALSE, terms="elapsed [all]")
# plot predictions
ggeffects::predict_response(best1, cov.fit = FALSE, terms="elapsed [all]")
# plot predictions
ggeffects::predict_response(best1, terms = "social", cov.fit = FALSE, terms="elapsed [all]")
# plot predictions
ggeffects::predict_response(best1, terms = "social") cov.fit = FALSE, terms="elapsed [all]")
# plot predictions
ggeffects::predict_response(best1, terms = "social")
# plot predictions
pred <- ggeffects::predict_response(best1, terms = "social", cov.fit = FALSE, terms="elapsed [all]")
plot(pred)
# plot predictions
pred <- ggeffects::predict_response(best1, terms = "social", cov.fit = FALSE, terms="elapsed [all]")
# plot predictions
pred <- ggeffects::predict_response(best1, cov.fit = FALSE, terms="elapsed [all]")
plot(pred)
# plot predictions
pred <- ggeffects::predict_response(best1, terms = social, cov.fit = FALSE, terms="elapsed [all]")
# plot predictions
pred <- ggeffects::predict_response(m1, terms = "social", cov.fit = FALSE, terms="elapsed [all]")
# plot predictions
pred <- ggeffects::predict_response(best1, terms = "social", cov.fit = FALSE)
# test difference between the groups with interaction of time
m1 <- glmmTMB(daily_dist ~ social * scale(elapsed) + (1|id),
data = datam1,
na.action = "na.fail")
# model selection
dm1 <- dredge(m1)
# print best model on AICc
best1 <- get.models(dm1, delta==0)[[1]]
summary(best1)
# post-hoc tukey
emmeans(best1)
# post-hoc tukey
emmeans(best1, ~ social)
# post-hoc tukey
emmeans(best1, ~ social, type = "tukey")
?emmeans
# post-hoc tukey
emmeans(best1, ~ social, type = "tukey", type = "response")
best1
# post-hoc tukey
emmeans(m1, ~ social, type = "tukey", type = "response")
# test difference between the groups with interaction of time as a quadratic
m1 <- glmmTMB(daily_dist ~ social * (scale(elapsed) + I(scale(elapsed)^2))+ (1|id),
data = datam1)
# test difference between the groups with interaction of time
m1 <- glmmTMB(daily_dist ~ social * scale(elapsed) + (1|id),
data = datam1)
# model selection
dm1 <- dredge(m1)
# print best model on AICc
best1 <- get.models(dm1, delta==0)[[1]]
# post-hoc tukey
emmeans(best1, ~ social, type = "tukey", type = "response")
# test difference between the groups with interaction of time as a quadratic
na.action = "na.fail"
# test difference between the groups with interaction of time as a quadratic
options(na.action = "na.fail")
m1 <- glmmTMB(daily_dist ~ social * (scale(elapsed) + I(scale(elapsed)^2))+ (1|id),
data = datam1)
# model selection
dm1 <- dredge(m1)
# print best model on AICc
best1 <- get.models(dm1, delta==0)[[1]]
summary(best1)
# post-hoc tukey
emmeans(best1, ~ social, type = "tukey", type = "response")
options(na.action = "na.omit")
# post-hoc tukey
emmeans(best1, ~ social, type = "tukey", type = "response")
