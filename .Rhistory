geom_line(colour = group)+
geom_ribbon(alpha = 0.3)+
xlab("Days post-release") +
ylab("Predicted values of daily distance moved (m)") +
theme_minimal()+
scale_fill_viridis_d()
# plot predictions
ggplot(pred, aes(x, predicted, fill = group, ymin = conf.low, ymax = conf.high)) +
geom_line(aes(colour = group))+
geom_ribbon(alpha = 0.3)+
xlab("Days post-release") +
ylab("Predicted values of daily distance moved (m)") +
theme_minimal()+
scale_fill_viridis_d()
# plot predictions
ggplot(pred, aes(x, predicted, fill = group, ymin = conf.low, ymax = conf.high)) +
geom_line(aes(colour = group))+
geom_ribbon(alpha = 0.3)+
xlab("Days post-release") +
ylab("Predicted values of daily distance moved (m)") +
theme_minimal()+
scale_fill_viridis_d()+
scale_colour_viridis_d()
# plot daily distance over time as social group means
ggplot(sum1, aes(date, dist, ymin = lower, ymax = upper)) +
geom_path(aes(colour = social)) +
geom_ribbon(aes(fill = social), alpha = 0.7) +
xlab("Days post-release") +
ylab("Daily distance moved (m)") +
theme_minimal() +
scale_fill_viridis_d()+
scale_colour_viridis_d()
# plot predictions
ggplot(pred, aes(x, predicted, fill = group, ymin = conf.low, ymax = conf.high)) +
geom_line(aes(colour = group))+
geom_ribbon(alpha = 0.3)+
xlab("Days post-release") +
ylab("Predicted values of daily distance moved (m)") +
theme_minimal()+
scale_fill_viridis_d()+
scale_colour_viridis_d()
summary(best1)
# post-hoc tukey
emmeans(best1, pairwise ~ social, type = "response")
emtrends(best1, pairwise ~ social, type = "response")
emtrends(best1, pairwise ~ social, var = "elapsed". type = "response")
emtrends(best1, pairwise ~ social, var = "elapsed", type = "response")
emtrends(best1, pairwise ~ social, var = scale(elapsed), type = "response")
emtrends(best1, pairwise ~ social, var = "scale(elapsed)", type = "response")
emtrends(best1, pairwise ~ social, var = "scale(elapsed)")
emtrends(best1, pairwise ~ social, var = "elapsed")
emtrends(best1, pairwise ~ social, var = "elapsed2")
# post-hoc comparison of slopes
emtrends(best1, pairwise ~ social, var = "elapsed")
# read in data and filter to reinforcement period
datam2 <- read.csv("results/daily_distance_between_roosts.csv") %>%
# add metadata
left_join(dplyr::select(metadata, c("id", "cohort"))) %>%
# format dates as dates
mutate(date = as_date(date)) %>%
# limit to reinforcement period
filter(date %in% rein_dates) %>%
# add a time elapsed post-release variable
mutate(elapsed = as.numeric(date - as_date("2023-06-10"))) %>%
# add column for membership to social group
mutate(social = ifelse(id %in% club, "Reinforcer - exclusive", ifelse(cohort == "Resident", "Resident", "Reinforcer - mixed"))) %>%
# convert group to factor and set resident as the intercept
mutate(social = factor(social, levels = c("Resident", "Reinforcer - mixed", "Reinforcer - exclusive"))) %>%
# add quadratic term for time
mutate(elapsed2 = elapsed^2)
# create social group means
sum2 <- datam2 %>%
group_by(date, social) %>%
summarise(dist = mean(distance_previous),
upper = dist + std.error(distance_previous),
lower = dist - std.error(distance_previous)) %>%
arrange(date)
# plot roost displacement over time as social group means
ggplot(sum2, aes(date, dist, ymin = lower, ymax = upper)) +
geom_path(aes(colour = social)) +
geom_ribbon(aes(fill = social), alpha = 0.7) +
xlab("Days post-release") +
ylab("Distance between consecutive roosts (m)") +
theme_minimal() +
scale_fill_viridis_d()+
scale_colour_viridis_d()
# distribution of movement data
hist(datam2$distance_previous)
ggqqplot(datam2$distance_previous)
# correct left skew
hist(log1p(datam2$distance_previous))
ggqqplot(log1p(datam2$distance_previous))
# test difference between the groups with interaction of time as a quadratic
m2 <- glmmTMB(distance_previous ~ social * (scale(elapsed) + scale(elapsed2))+ (1|id),
data = datam2,
na.action = "na.fail")
View(datam2)
# model selection
dm2 <- dredge(m2)
m2
summary(m2)
# test difference between the groups with interaction of time as a quadratic
m2 <- glmmTMB(log1p(distance_previous) ~ social * (scale(elapsed) + scale(elapsed2))+ (1|id),
data = datam2,
na.action = "na.fail")
# model selection
dm2 <- dredge(m2)
# print best model on AICc
best2 <- get.models(dm2, delta==0)[[1]]
summary(best2)
# post-hoc comparison of means
emmeans(best2, pairwise ~ social, type = "response")
# post-hoc comparison of slopes
emtrends(best2, pairwise ~ social, var = "elapsed")
# check residuals
hist(residuals(best2))
ggqqplot(residuals(best2))
# plot effects
plot_model(best2)
# marginal effects
pred <- predict_response(best2, terms = c("elapsed", "social"))
# plot predictions
ggplot(pred2, aes(x, predicted, fill = group, ymin = conf.low, ymax = conf.high)) +
geom_line(aes(colour = group))+
geom_ribbon(alpha = 0.3)+
xlab("Days post-release") +
ylab("Predicted values of daily distance moved (m)") +
theme_minimal()+
scale_fill_viridis_d()+
scale_colour_viridis_d()
# marginal effects
pred2 <- predict_response(best2, terms = c("elapsed", "social"))
# plot predictions
ggplot(pred2, aes(x, predicted, fill = group, ymin = conf.low, ymax = conf.high)) +
geom_line(aes(colour = group))+
geom_ribbon(alpha = 0.3)+
xlab("Days post-release") +
ylab("Predicted values of daily distance moved (m)") +
theme_minimal()+
scale_fill_viridis_d()+
scale_colour_viridis_d()
# plot roost displacement over time as social group means
ggplot(sum2, aes(date, dist, ymin = lower, ymax = upper)) +
geom_path(aes(colour = social)) +
geom_ribbon(aes(fill = social), alpha = 0.7) +
xlab("Days post-release") +
ylab("Distance between consecutive roosts (m)") +
theme_minimal() +
scale_fill_viridis_d()+
scale_colour_viridis_d()
# plot predictions
ggplot(pred2, aes(x, predicted, fill = group, ymin = conf.low, ymax = conf.high)) +
geom_line(aes(colour = group))+
geom_ribbon(alpha = 0.2)+
xlab("Days post-release") +
ylab("Predicted values of roost displacement (m)") +
theme_minimal()+
scale_fill_viridis_d()+
scale_colour_viridis_d()
# plot roost displacement over time as social group means
ggplot(sum2, aes(date, dist, ymin = lower, ymax = upper)) +
geom_path(aes(colour = social)) +
geom_ribbon(aes(fill = social), alpha = 0.2) +
xlab("Days post-release") +
ylab("Distance between consecutive roosts (m)") +
theme_minimal() +
scale_fill_viridis_d()+
scale_colour_viridis_d()
# post-hoc comparison of slopes
emtrends(best1, pairwise ~ social, var = "elapsed")
# post-hoc comparison of means
emmeans(best1, pairwise ~ social, type = "response")
# post-hoc comparison of means
emmeans(best2, pairwise ~ social, type = "response")
# read in data and filter to reinforcement period
datam3 <- read.csv("results/daily_roost_distance_from_release.csv") %>%
# add metadata
left_join(dplyr::select(metadata, c("id", "cohort"))) %>%
# format dates as dates
mutate(date = as_date(date)) %>%
# limit to reinforcement period
filter(date %in% rein_dates) %>%
# add a time elapsed post-release variable
mutate(elapsed = as.numeric(date - as_date("2023-06-10"))) %>%
# add column for membership to social group
mutate(social = ifelse(id %in% club, "Reinforcer - exclusive", ifelse(cohort == "Resident", "Resident", "Reinforcer - mixed"))) %>%
# convert group to factor and set resident as the intercept
mutate(social = factor(social, levels = c("Resident", "Reinforcer - mixed", "Reinforcer - exclusive"))) %>%
# add quadratic term for time
mutate(elapsed2 = elapsed^2)
# create social group means
sum3 <- datam3 %>%
group_by(date, social) %>%
summarise(dist = mean(dist_release),
upper = dist + std.error(dist_release),
lower = dist - std.error(dist_release)) %>%
arrange(date)
# plot distance from release site over time as social group means
ggplot(sum3, aes(date, dist, ymin = lower, ymax = upper)) +
geom_path(aes(colour = social)) +
geom_ribbon(aes(fill = social), alpha = 0.2) +
xlab("Days post-release") +
ylab("Distance from release site (m)") +
theme_minimal() +
scale_fill_viridis_d()+
scale_colour_viridis_d()
# distribution of movement data
hist(datam3$dist_release)
ggqqplot(datam3$dist_release)
# correct left skew - still not great but a bit better
hist(sqrt(datam3$dist_release))
ggqqplot(sqrt(datam3$dist_release))
# test difference between the groups with interaction of time as a quadratic
m3 <- glmmTMB(sqrt(dist_release) ~ social * (scale(elapsed) + scale(elapsed2))+ (1|id),
data = datam3,
na.action = "na.fail")
# model selection
dm3 <- dredge(m3)
# print best model on AICc
best3 <- get.models(dm3, delta==0)[[1]]
summary(best3)
# post-hoc comparison of means
emmeans(best3, pairwise ~ social, type = "response")
# post-hoc comparison of slopes
emtrends(best3, pairwise ~ social, var = "elapsed")
# check residuals
hist(residuals(best3))
ggqqplot(residuals(best3))
# Packages
pacman::p_load(adehabitatHR, amt, atlastools, beepr, effects, emmeans, ggeffects, ggfortify, ggmap, ggnewscale, ggforce, ggpubr, ggraph, ggridges, ggspatial, glmmTMB, gtools, igraph, janitor, jtools, lme4, lmerTest, move2, momentuHMM, MuMIn, performance, plotrix, readxl, scales, scattermore, sf, sjPlot, sp, suncalc, survival, survminer, terra, tidygraph, tidyterra, tidyverse, viridis, wildlifeDI)
# check model
check_model(best3)
# check model
check_model(best1)
# Packages
pacman::p_load(adehabitatHR, amt, atlastools, beepr, effects, emmeans, ggeffects, ggfortify, ggmap, ggnewscale, ggforce, ggpubr, ggraph, ggridges, ggspatial, glmmTMB, gtools, igraph, janitor, jtools, lme4, lmerTest, move2, momentuHMM, MuMIn, performance, plotrix, readxl, scales, scattermore, sf, sjPlot, sp, suncalc, survival, survminer, terra, tidygraph, tidyterra, tidyverse, viridis, wildlifeDI)
# Metadata - translocation information
metadata  <- read.csv("data/metadata.csv") %>%
clean_names() %>%
rename(id = identity,
mortality = mortality_or_capture) %>%
mutate(start_date = as_date(dmy(start_date)),
end_date = as_date(dmy(end_date)),
mortality = as_date(dmy(mortality)))
# social group membership
club <- c("Rowan", "Rory", "Fauna", "Zeus", "Rocky", "Sofi", "Loki", "Avery", "Maeve")
# define reinforcer date period
rein_dates <- seq.Date(from = as_date("2023-06-11"), to = as_date("2023-08-05"), by = "day")
# read in data and filter to reinforcement period
datam1 <- read.csv("results/daily_distance_moved.csv") %>%
# add metadata
left_join(dplyr::select(metadata, c("id", "cohort"))) %>%
# format dates as dates
mutate(date = as_date(date_bird)) %>%
# limit to reinforcement period
filter(date %in% rein_dates) %>%
# add a time elapsed post-release variable
mutate(elapsed = as.numeric(date - as_date("2023-06-10"))) %>%
# add column for membership to social group
mutate(social = ifelse(id %in% club, "Reinforcer - exclusive", ifelse(cohort == "Resident", "Resident", "Reinforcer - mixed"))) %>%
# convert group to factor and set resident as the intercept
mutate(social = factor(social, levels = c("Resident", "Reinforcer - mixed", "Reinforcer - exclusive"))) %>%
# add quadratic term for time
mutate(elapsed2 = elapsed^2)
# create social group means
sum1 <- datam1 %>%
group_by(date, social) %>%
summarise(dist = mean(daily_dist),
upper = dist + std.error(daily_dist),
lower = dist - std.error(daily_dist)) %>%
arrange(date)
# plot daily distance over time as social group means
ggplot(sum1, aes(date, dist, ymin = lower, ymax = upper)) +
geom_path(aes(colour = social)) +
geom_ribbon(aes(fill = social), alpha = 0.2) +
xlab("Days post-release") +
ylab("Daily distance moved (m)") +
theme_minimal() +
scale_fill_viridis_d()+
scale_colour_viridis_d()
# distribution of movement data
hist(datam1$daily_dist)
ggqqplot(datam1$daily_dist)
# test difference between the groups with interaction of time as a quadratic
m1 <- glmmTMB(daily_dist ~ social * (scale(elapsed) + scale(elapsed2))+ (1|id),
data = datam1,
na.action = "na.fail")
# model selection
dm1 <- dredge(m1)
# print best model on AICc
best1 <- get.models(dm1, delta==0)[[1]]
summary(best1)
# check model
check_model(best1)
# read in data and filter to reinforcement period
datam2 <- read.csv("results/daily_distance_between_roosts.csv") %>%
# add metadata
left_join(dplyr::select(metadata, c("id", "cohort"))) %>%
# format dates as dates
mutate(date = as_date(date)) %>%
# limit to reinforcement period
filter(date %in% rein_dates) %>%
# add a time elapsed post-release variable
mutate(elapsed = as.numeric(date - as_date("2023-06-10"))) %>%
# add column for membership to social group
mutate(social = ifelse(id %in% club, "Reinforcer - exclusive", ifelse(cohort == "Resident", "Resident", "Reinforcer - mixed"))) %>%
# convert group to factor and set resident as the intercept
mutate(social = factor(social, levels = c("Resident", "Reinforcer - mixed", "Reinforcer - exclusive"))) %>%
# add quadratic term for time
mutate(elapsed2 = elapsed^2)
# create social group means
sum2 <- datam2 %>%
group_by(date, social) %>%
summarise(dist = mean(distance_previous),
upper = dist + std.error(distance_previous),
lower = dist - std.error(distance_previous)) %>%
arrange(date)
# plot roost displacement over time as social group means
ggplot(sum2, aes(date, dist, ymin = lower, ymax = upper)) +
geom_path(aes(colour = social)) +
geom_ribbon(aes(fill = social), alpha = 0.2) +
xlab("Days post-release") +
ylab("Distance between consecutive roosts (m)") +
theme_minimal() +
scale_fill_viridis_d()+
scale_colour_viridis_d()
# distribution of movement data
hist(datam2$distance_previous)
ggqqplot(datam2$distance_previous)
# correct left skew
hist(log1p(datam2$distance_previous))
ggqqplot(log1p(datam2$distance_previous))
# check model
check_model(best2)
# test difference between the groups with interaction of time as a quadratic
m2 <- glmmTMB(log1p(distance_previous) ~ social * (scale(elapsed) + scale(elapsed2))+ (1|id),
data = datam2,
na.action = "na.fail")
# model selection
dm2 <- dredge(m2)
# print best model on AICc
best2 <- get.models(dm2, delta==0)[[1]]
summary(best2)
# check model
check_model(best2)
# read in data and filter to reinforcement period
datam3 <- read.csv("results/daily_roost_distance_from_release.csv") %>%
# add metadata
left_join(dplyr::select(metadata, c("id", "cohort"))) %>%
# format dates as dates
mutate(date = as_date(date)) %>%
# limit to reinforcement period
filter(date %in% rein_dates) %>%
# add a time elapsed post-release variable
mutate(elapsed = as.numeric(date - as_date("2023-06-10"))) %>%
# add column for membership to social group
mutate(social = ifelse(id %in% club, "Reinforcer - exclusive", ifelse(cohort == "Resident", "Resident", "Reinforcer - mixed"))) %>%
# convert group to factor and set resident as the intercept
mutate(social = factor(social, levels = c("Resident", "Reinforcer - mixed", "Reinforcer - exclusive"))) %>%
# add quadratic term for time
mutate(elapsed2 = elapsed^2)
# create social group means
sum3 <- datam3 %>%
group_by(date, social) %>%
summarise(dist = mean(dist_release),
upper = dist + std.error(dist_release),
lower = dist - std.error(dist_release)) %>%
arrange(date)
# plot distance from release site over time as social group means
ggplot(sum3, aes(date, dist, ymin = lower, ymax = upper)) +
geom_path(aes(colour = social)) +
geom_ribbon(aes(fill = social), alpha = 0.2) +
xlab("Days post-release") +
ylab("Distance from release site (m)") +
theme_minimal() +
scale_fill_viridis_d()+
scale_colour_viridis_d()
# distribution of movement data
hist(datam3$dist_release)
ggqqplot(datam3$dist_release)
# correct left skew - still not great but a bit better
hist(sqrt(datam3$dist_release))
ggqqplot(sqrt(datam3$dist_release))
# test difference between the groups with interaction of time as a quadratic
m3 <- glmmTMB(sqrt(dist_release) ~ social * (scale(elapsed) + scale(elapsed2))+ (1|id),
data = datam3,
na.action = "na.fail")
# model selection
dm3 <- dredge(m3)
# print best model on AICc
best3 <- get.models(dm3, delta==0)[[1]]
summary(best3)
# check model
check_model(best3)
# post-hoc comparison of means
emmeans(best3, pairwise ~ social, type = "response")
# post-hoc comparison of slopes
emtrends(best3, pairwise ~ social, var = "elapsed")
# plot effects
plot_model(best3)
?plot_model
# marginal effects
pred3 <- predict_response(best3, terms = c("elapsed", "social"))
# read in data and filter to reinforcement period
datam3 <- read.csv("results/daily_roost_distance_from_release.csv") %>%
# add metadata
left_join(dplyr::select(metadata, c("id", "cohort"))) %>%
# format dates as dates
mutate(date = as_date(date)) %>%
# limit to reinforcement period
filter(date %in% rein_dates) %>%
# add a time elapsed post-release variable
mutate(elapsed = as.numeric(date - as_date("2023-06-10"))) %>%
# add column for membership to social group
mutate(social = ifelse(id %in% club, "Reinforcer - exclusive", ifelse(cohort == "Resident", "Resident", "Reinforcer - mixed"))) %>%
# convert group to factor and set resident as the intercept
mutate(social = factor(social, levels = c("Resident", "Reinforcer - mixed", "Reinforcer - exclusive"))) %>%
# add quadratic term for time
mutate(elapsed2 = elapsed^2)
# create social group means
sum3 <- datam3 %>%
group_by(date, social) %>%
summarise(dist = mean(dist_release),
upper = dist + std.error(dist_release),
lower = dist - std.error(dist_release)) %>%
arrange(date)
# plot distance from release site over time as social group means
ggplot(sum3, aes(date, dist, ymin = lower, ymax = upper)) +
geom_path(aes(colour = social)) +
geom_ribbon(aes(fill = social), alpha = 0.2) +
xlab("Days post-release") +
ylab("Distance from release site (m)") +
theme_minimal() +
scale_fill_viridis_d()+
scale_colour_viridis_d()
# distribution of movement data
hist(datam3$dist_release)
ggqqplot(datam3$dist_release)
# correct left skew - still not great but a bit better
hist(sqrt(datam3$dist_release))
ggqqplot(sqrt(datam3$dist_release))
# test difference between the groups with interaction of time as a quadratic
m3 <- glmmTMB(sqrt(dist_release) ~ social * (scale(elapsed) + scale(elapsed2))+ (1|id),
data = datam3,
na.action = "na.fail")
# model selection
dm3 <- dredge(m3)
# print best model on AICc
best3 <- get.models(dm3, delta==0)[[1]]
summary(best3)
# check model
check_model(best3)
# post-hoc comparison of means
emmeans(best3, pairwise ~ social, type = "response")
# post-hoc comparison of slopes
emtrends(best3, pairwise ~ social, var = "elapsed")
# plot effects
plot_model(best3)
# marginal effects
pred3 <- predict_response(best3, terms = c("elapsed", "social"))
# plot predictions
ggplot(pred3, aes(x, predicted, fill = group, ymin = conf.low, ymax = conf.high)) +
geom_line(aes(colour = group))+
geom_ribbon(alpha = 0.2)+
xlab("Days post-release") +
ylab("Predicted values of distance from release site (m)") +
theme_minimal()+
scale_fill_viridis_d()+
scale_colour_viridis_d()
# plot distance from release site over time as social group means
ggplot(sum3, aes(date, dist, ymin = lower, ymax = upper)) +
geom_path(aes(colour = social)) +
geom_ribbon(aes(fill = social), alpha = 0.2) +
xlab("Days post-release") +
ylab("Distance from release site (m)") +
theme_minimal() +
scale_fill_viridis_d()+
scale_colour_viridis_d()
# read in data and filter to reinforcement period
datam4 <- read.csv("results/daily_hr_area.csv") %>%
# add metadata
left_join(dplyr::select(metadata, c("id", "cohort"))) %>%
# format dates as dates
mutate(date = as_date(date)) %>%
# limit to reinforcement period
filter(date %in% rein_dates) %>%
# add a time elapsed post-release variable
mutate(elapsed = as.numeric(date - as_date("2023-06-10"))) %>%
# add column for membership to social group
mutate(social = ifelse(id %in% club, "Reinforcer - exclusive", ifelse(cohort == "Resident", "Resident", "Reinforcer - mixed"))) %>%
# convert group to factor and set resident as the intercept
mutate(social = factor(social, levels = c("Resident", "Reinforcer - mixed", "Reinforcer - exclusive"))) %>%
# add quadratic term for time
mutate(elapsed2 = elapsed^2)
# create social group means
sum4 <- datam4 %>%
group_by(date, social) %>%
summarise(dist = mean(area),
upper = dist + std.error(area),
lower = dist - std.error(area)) %>%
arrange(date)
# plot distance from release site over time as social group means
ggplot(sum4, aes(date, dist, ymin = lower, ymax = upper)) +
geom_path(aes(colour = social)) +
geom_ribbon(aes(fill = social), alpha = 0.2) +
xlab("Days post-release") +
ylab("Home range 50% KUD (ha)") +
theme_minimal() +
scale_fill_viridis_d()+
scale_colour_viridis_d()
# distribution of movement data
hist(datam4$area)
