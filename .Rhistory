# summary
summary(best2)
# marginal effects
pred2 <- predict_response(best2, terms = c("elapsed [all]", "social"))
# plot predictions
ggplot(pred2, aes(x, predicted, fill = group, ymin = conf.low, ymax = conf.high)) +
geom_line(aes(colour = group))+
geom_ribbon(alpha = 0.2)+
xlab("Days post-reinforcement") +
ylab("Predicted values of roost displacement (m)") +
theme_minimal()+
scale_fill_viridis_d()+
scale_colour_viridis_d()
# read in data and filter to reinforcement period
datam3 <- read.csv("results/daily_roost_distance_from_release.csv") %>%
# add metadata
left_join(dplyr::select(metadata, c("id", "cohort"))) %>%
# format dates as dates
mutate(date = as_date(date)) %>%
# limit to reinforcement period
filter(date %in% rein_dates) %>%
# add a time elapsed post-release variable
mutate(elapsed = as.numeric(date - as_date("2023-06-10"))) %>%
# add column for membership to social group
mutate(social = ifelse(id %in% club, "Reinforcer - exclusive", ifelse(cohort == "Resident", "Resident", "Reinforcer - mixed"))) %>%
# convert group to factor and set resident as the intercept
mutate(social = factor(social, levels = c("Resident", "Reinforcer - mixed", "Reinforcer - exclusive"))) %>%
# exclude daisy
filter(!id == "Daisy")
# create social group means
sum3 <- datam3 %>%
group_by(date, social) %>%
summarise(dist = mean(dist_release),
upper = dist + 1.96 * std.error(dist_release),
lower = dist - 1.96 * std.error(dist_release)) %>%
arrange(date)
# plot distance from release site over time as social group means
ggplot(sum3, aes(date, dist, ymin = lower, ymax = upper)) +
geom_path(aes(colour = social)) +
geom_ribbon(aes(fill = social), alpha = 0.2) +
xlab("Days post-reinforcement") +
ylab("Distance from release site (m)") +
theme_minimal() +
scale_fill_viridis_d()+
scale_colour_viridis_d()
# test difference between the groups with interaction of time as a quadratic
m3 <- glmmTMB(sqrt(dist_release) ~ social * (scale(elapsed) + I(scale(elapsed)^2)) + (1|id),
data = datam3,
na.action = "na.fail")
# model selection
dm3 <- dredge(m3, fixed = "cond(social)")
View(dm3)
# parsimonious model where delta <2 and fewest predictors
# in this case only one model (the top ranked) delta AICc < 2
best3 <- get.models(dm3, delta <2)[[1]]
# summary
summary(best3)
# marginal effects
pred3 <- predict_response(best3, terms = c("elapsed [all]", "social"))
# plot predictions
ggplot(pred3, aes(x, predicted, fill = group, ymin = conf.low, ymax = conf.high)) +
geom_line(aes(colour = group))+
geom_ribbon(alpha = 0.2)+
xlab("Days post-reinforcement") +
ylab("Predicted values of distance from release site (m)") +
theme_minimal()+
scale_fill_viridis_d()+
scale_colour_viridis_d()
# Google and STadia API key for ggmaps
ggmap::register_google(key = readChar("apikey_google.txt", nchars = file.info("apikey_google.txt")$size))
map_z15 <- get_map(c(144.4380, -37.9000), zoom=15, maptype = "satellite")
ggmap(map_z15)+
# plot roosts colour by time
geom_point(aes(longitude, latitude, colour = date),
size = 2, data = datam2, inherit.aes = FALSE)+
# add release location
geom_point(aes(144.434323, -37.902374),
colour = "white", size = 5, shape = 13, inherit.aes = FALSE)+
# add fence
geom_spatvector(data = mtr, inherit.aes = FALSE, fill = NA, colour = "white",
linetype = "longdash")+
# wrap by period
facet_wrap(~social)+
# theme options
scale_colour_viridis_c(trans = "date", name = "2023")+
theme_void()+
scale_y_continuous(expand = expansion(mult = c(0, 0.01)))+
#theme(legend.position="bottom",
#legend.key.width = unit(3, 'cm'),
#strip.text = element_text(size = 13))+
# add north in just the resident facet panel
annotation_north_arrow(data  = subset(datam2, social == "Reinforcer - exclusive"),
location = "tr",
height = unit(0.8, "cm"), width = unit(0.7, "cm"),
style = north_arrow_orienteering(text_col = "black"))+
# add scale bar in just the resident facet panel
annotation_scale(data  = subset(datam2, social == "Reinforcer - exclusive"),
location = "br", text_col = "black",
pad_x = unit(0.1, "cm"), pad_y = unit(0.4, "cm"))+
# legend and label format
ggplot2::theme(legend.position = "bottom",
legend.key.width = unit(3,"cm"),
strip.text = element_text(size = 11))
# Define fence polygons (zones 1 and 2)
mtr <- rbind(
## zone 1
c(-37.897319, 144.429048), # S end of NW diagonal
c(-37.894066, 144.432334), # N end of NW diagonal, i.e. NW corner
c(-37.894749, 144.438305), # bend at main gate
c(-37.894693, 144.438324), # main gate
c(-37.894803, 144.439214), # bend before N Z1/2 gate
c(-37.894718, 144.439337), # N Z1/2 gate, i.e. NE corner
## zone 2
c(-37.892433, 144.440236), # N boundary internal aviary/Z2 i.e. NW corner
c(-37.892803, 144.443374), # Z2 northern boundary bend 1
c(-37.893634, 144.444076), # Z2 northern boundary bend 2
c(-37.894585, 144.447739), # N end of Z2/Z3 boundary, i.e. NE corner
c(-37.896515, 144.446789), # Z2/Z3 boundary bend 1
c(-37.896726, 144.446099), # Z2/Z3 boundary bend 2
c(-37.897964, 144.445706), # Z2/Z3 boundary bend 3
c(-37.899960, 144.444517), # S end of Z2/Z3 boundary, i.e. SE corner
# hashed lines are to remove the gap of the rock wallaby pen
#c(-37.899908, 144.444288), # Z2/btrw NE corner
#c(-37.898280, 144.440662), # Z1/btrw pen NW corner
## zone 1
#c(-37.900692, 144.440368), # Z1/btrw SW corner
#c(-37.902610, 144.443002), # Z1/btrw SE corner
c(-37.909538, 144.439648), # Z1 SE corner
c(-37.908999, 144.434965), # Z1 southern boundary bend 1
c(-37.907537, 144.433359), # Z1 southern boundary bend 2
c(-37.905958, 144.430140), # Z1 southern boundary bend 3
c(-37.905486, 144.429479), # Z1 southern boundary bend 4
c(-37.904649, 144.427566), # Z1 SW corner
c(-37.897319, 144.429048)  # S end of NW diagonal
) %>%  vect(type = "polygons", crs = "EPSG:4326") %>%
# transpose
t()
ggmap(map_z15)+
# plot roosts colour by time
geom_point(aes(longitude, latitude, colour = date),
size = 2, data = datam2, inherit.aes = FALSE)+
# add release location
geom_point(aes(144.434323, -37.902374),
colour = "white", size = 5, shape = 13, inherit.aes = FALSE)+
# add fence
geom_spatvector(data = mtr, inherit.aes = FALSE, fill = NA, colour = "white",
linetype = "longdash")+
# wrap by period
facet_wrap(~social)+
# theme options
scale_colour_viridis_c(trans = "date", name = "2023")+
theme_void()+
scale_y_continuous(expand = expansion(mult = c(0, 0.01)))+
#theme(legend.position="bottom",
#legend.key.width = unit(3, 'cm'),
#strip.text = element_text(size = 13))+
# add north in just the resident facet panel
annotation_north_arrow(data  = subset(datam2, social == "Reinforcer - exclusive"),
location = "tr",
height = unit(0.8, "cm"), width = unit(0.7, "cm"),
style = north_arrow_orienteering(text_col = "black"))+
# add scale bar in just the resident facet panel
annotation_scale(data  = subset(datam2, social == "Reinforcer - exclusive"),
location = "br", text_col = "black",
pad_x = unit(0.1, "cm"), pad_y = unit(0.4, "cm"))+
# legend and label format
ggplot2::theme(legend.position = "bottom",
legend.key.width = unit(3,"cm"),
strip.text = element_text(size = 11))
# save
ggsave("maps/roost_location_social_groups.png", dpi = 300, bg = 'white')
# read in data and filter to reinforcement period
datam4 <- read.csv("results/daily_hr.csv") %>%
# add metadata
left_join(dplyr::select(metadata, c("id", "cohort"))) %>%
# format dates as dates
mutate(date = as_date(date)) %>%
# limit to reinforcement period
filter(date %in% rein_dates) %>%
# add a time elapsed post-release variable
mutate(elapsed = as.numeric(date - as_date("2023-06-10"))) %>%
# add column for membership to social group
mutate(social = ifelse(id %in% club, "Reinforcer - exclusive", ifelse(cohort == "Resident", "Resident", "Reinforcer - mixed"))) %>%
# convert group to factor and set resident as the intercept
mutate(social = factor(social, levels = c("Resident", "Reinforcer - mixed", "Reinforcer - exclusive"))) %>%
# exclude daisy
filter(!id == "Daisy")
# create social group means
sum4 <- datam4 %>%
group_by(date, social) %>%
summarise(area = mean(kud50),
upper = area + 1.96 * std.error(kud50),
lower = area - 1.96 * std.error(kud50)) %>%
arrange(date)
# and overall means
mean4 <- datam4 %>%
group_by(social) %>%
summarise(mean = mean(kud50),
se = std.error(kud50))
# plot home range size over time as social group means
ggplot(sum4, aes(date, area, ymin = lower, ymax = upper)) +
geom_path(aes(colour = social)) +
geom_ribbon(aes(fill = social), alpha = 0.2) +
xlab("Days post-reinforcement") +
ylab("Home range 50% KUD (ha)") +
theme_minimal() +
scale_fill_viridis_d()+
scale_colour_viridis_d()
# test difference between the groups with interaction of time as a quadratic
m4 <- glmmTMB(log1p(kud50) ~ social * (scale(elapsed) + I(scale(elapsed)^2)) + (1|id),
data = datam4,
na.action = "na.fail")
# model selection
dm4 <- dredge(m4, fixed = "cond(social)")
View(dm4)
# parsimonious model where delta <2 and fewest predictors
# in this case only one model (the top ranked) delta AICc < 2
best4 <- get.models(dm4, delta <2)[[1]]
# summary
summary(best4)
# marginal effects
pred4 <- predict_response(best4, terms = c("elapsed [all]", "social"))
# plot predictions
ggplot(pred4, aes(x, predicted, fill = group, ymin = conf.low, ymax = conf.high)) +
geom_line(aes(colour = group))+
geom_ribbon(alpha = 0.2)+
xlab("Days post-reinforcement") +
ylab("Predicted values of home range area (ha)") +
theme_minimal()+
scale_fill_viridis_d()+
scale_colour_viridis_d()
# read in data and clean up
datam5 <- read_xlsx("data/healthchecks.xlsx") %>%
clean_names() %>%
rename(id = identity) %>%
select(id, date, weight) %>%
# add metadata
left_join(select(metadata, c(id, start_date, cohort))) %>%
drop_na() %>%
# format dates
mutate(date = as_date(date),
start_date = as_date(start_date, format = "%d/%m/%Y")) %>%
# calculate elapsed time and add status
mutate(elapsed = as.numeric(date - start_date)) %>%
# keep only reinforcers
filter(cohort == "Reinforcing") %>%
# add social group membership %>%
mutate(social = as_factor(ifelse(id %in% club, "Reinforcer - exclusive", ifelse(cohort == "Resident", "Resident", "Reinforcer - mixed")))) %>%
# keep only the latest pre-release values and assign to pre/post release
group_by(id) %>%
filter(elapsed > 0 | elapsed == max(elapsed[elapsed <= 0])) %>%
ungroup() %>%
mutate(status = as_factor(ifelse(elapsed > 0, "post-release", "pre-release"))) %>%
arrange(id) %>%
# filter to study period
filter(elapsed <70) %>%
# keep only required columns
select(c(id, weight, social, status)) %>%
# exclude daisy
filter(!id == "Daisy")
# plot weight pre and post-release
ggplot(datam5)+
geom_boxplot(aes(social, weight))+
theme_minimal()+
facet_wrap(~status)
# calculate difference
sum5 <- datam5 %>%
group_by(status, social) %>%
summarise(weight = mean(weight)) %>%
pivot_wider(names_from = status, values_from = weight) %>%
clean_names() %>%
mutate(diff = pre_release - post_release,
percent = diff / pre_release)
# test whether weight change differs between the social groups
m5 <- glmmTMB(weight ~ social * status + (1|id),
data = datam5)
summary(m5)
# means
emmeans(m5, pairwise ~ status)
# predictions
pred5 <- predict_response(m5a, terms = c("social", "status"))
# plot predictions - point range
ggplot(pred5, aes(x, predicted, colour = x))+
geom_pointrange(aes(ymin = conf.low, ymax = conf.high))+
xlab("Social group membership") +
ylab("Predicted values of weight (g)")+
facet_wrap(~group)+
theme_classic()
# plot predictions- trends
ggplot(pred5, aes(group, predicted, fill = x, ymin = conf.low, ymax = conf.high, group = x)) +
geom_line(aes(colour = x))+
geom_ribbon(alpha = 0.2)+
xlab(element_blank())+
ylab("Predicted weight (g)") +
theme_minimal()
# predictions
pred5 <- predict_response(m5a, terms = c("social", "status"))
# predictions
pred5 <- predict_response(m5, terms = c("social", "status"))
# plot predictions - point range
ggplot(pred5, aes(x, predicted, colour = x))+
geom_pointrange(aes(ymin = conf.low, ymax = conf.high))+
xlab("Social group membership") +
ylab("Predicted values of weight (g)")+
facet_wrap(~group)+
theme_classic()
# plot predictions- trends
ggplot(pred5, aes(group, predicted, fill = x, ymin = conf.low, ymax = conf.high, group = x)) +
geom_line(aes(colour = x))+
geom_ribbon(alpha = 0.2)+
xlab(element_blank())+
ylab("Predicted weight (g)") +
theme_minimal()
# set default theme options for all plots
pal <- c("#AFACAC","#2E3EDC", "#07A567")
theme <- function(){
list(
geom_line(aes(colour = group)),
geom_ribbon(alpha = 0.2),
xlab("Days post-reinforcement"),
scale_x_continuous(breaks=seq(0, 50, 10)),
theme_classic(),
ggplot2::theme(axis.title.y = element_text(hjust = 0.5, size = 10),
axis.title.x = element_text(size = 10)),
scale_color_manual(values = pal,
name = "Cohort and social group membership",
guide="none"),
scale_fill_manual(values = pal,,
name = "Cohort and social group membership",
guide="none")
)
}
# list of plots
g1 <- ggplot(pred1, aes(x, predicted, fill = group, ymin = conf.low, ymax = conf.high)) +
ylab("Daily distance moved (m)")+
theme()
g2 <- ggplot(pred2, aes(x, predicted, fill = group, ymin = conf.low, ymax = conf.high)) +
ylab("Roost displacement (m)")+
theme()
g3 <- ggplot(pred3, aes(x, predicted, fill = group, ymin = conf.low, ymax = conf.high)) +
ylab("Distance from release (m)")+
theme()
g4 <- ggplot(pred4, aes(x, predicted, fill = group, ymin = conf.low, ymax = conf.high)) +
ylab("Home range area (ha)")+
theme()
g5 <- ggplot(pred5, aes(group, predicted, fill = x, ymin = conf.low, ymax = conf.high, group = x)) +
geom_line(aes(colour = x))+
geom_ribbon(alpha = 0.2)+
theme_classic()+
xlab("Time period")+
ylab("Weight (g)") +
scale_colour_manual(values = c("#2E3EDC", "#07A567"), guide="none")+
scale_fill_manual(values = c("#2E3EDC", "#07A567"), guide="none")+
ggplot2::theme(axis.title.y = element_text(hjust = 0.5, size = 10),
axis.title.x = element_text(size = 10))
# make legend
temp <- ggplot(pred1, aes(x, predicted, fill = group, ymin = conf.low, ymax = conf.high)) +
geom_line(aes(colour = group)) +
geom_ribbon(alpha = 0.2) +
scale_color_manual(values = pal,
name = "Cohort and social group\nmembership")+
scale_fill_manual(values = pal,
name = "Cohort and social group\nmembership")+
ggplot2::theme(legend.title=element_text(size=10.5))
legend <- get_legend(temp)
# multi plot 3x2
combined_plot <- (g1 + g2 + g3)  / (g4 + g5 + legend) +
plot_annotation(tag_levels = 'A')
combined_plot
# save
ggsave("plots/reinforcer_outcomes.png", dpi = 400)
# summary
summary(best1)
# best models
tab_model(best1, best2, best3, best4, m5, show.est = TRUE, show.se = TRUE, show.ci = FALSE,
file = "results/m1-5_effects.xls")
# model selection table
ms <- mutate(as.data.frame(dm1), model = "distance daily") %>%
rbind(mutate(as.data.frame(dm2), model = "roost displacement")) %>%
rbind(mutate(as.data.frame(dm3), model = "release fidelity")) %>%
rbind(mutate(as.data.frame(dm4), model = "home range"))
write.csv(ms, "results/m1-4_modelselection.csv", row.names = FALSE)
# summary
summary(best2)
# post-hoc comparison of slopes
emtrends(best1, pairwise ~ social, var = "elapsed")
# post-hoc comparison of slopes
emtrends(best2, pairwise ~ social, var = "elapsed")
# define reinforcer date period
rein_dates <- seq.Date(from = as_date("2023-06-11"), to = as_date("2023-08-05"), by = "day")
# read in data and filter to reinforcement period
datam1 <- read.csv("results/daily_distance_moved.csv") %>%
# add metadata
left_join(dplyr::select(metadata, c("id", "cohort"))) %>%
# format dates as dates
mutate(date = as_date(date_bird)) %>%
# limit to reinforcement period
filter(date %in% rein_dates) %>%
# add a time elapsed post-release variable
mutate(elapsed = as.numeric(date - as_date("2023-06-10"))) %>%
# add column for membership to social group
mutate(social = ifelse(id %in% club, "Reinforcer - exclusive", ifelse(cohort == "Resident", "Resident", "Reinforcer - mixed"))) %>%
# convert group to factor and set resident as the intercept
mutate(social = factor(social, levels = c("Resident", "Reinforcer - mixed", "Reinforcer - exclusive"))) %>%
# exclude daisy
filter(!id == "Daisy")
# create social group means
sum1 <- datam1 %>%
group_by(date, social) %>%
summarise(dist = mean(daily_dist),
upper = dist + 1.96 * std.error(daily_dist),
lower = dist - 1.96 * std.error(daily_dist)) %>%
arrange(date)
# plot daily distance over time as social group means
ggplot(sum1, aes(date, dist, ymin = lower, ymax = upper)) +
geom_path(aes(colour = social)) +
geom_ribbon(aes(fill = social), alpha = 0.2) +
xlab("Days post-reinforcement") +
ylab("Daily distance moved (m)") +
theme_minimal() +
scale_fill_viridis_d()+
scale_colour_viridis_d()
# distribution of movement data
hist(datam1$daily_dist)
ggqqplot(datam1$daily_dist)
# test difference between the groups with interaction of time as a quadratic
m1 <- glmmTMB(daily_dist ~ social * (scale(elapsed) + I(scale(elapsed)^2)) + (1|id),
data = datam1,
na.action = "na.fail")
# model selection
dm1 <- dredge(m1, fixed = "cond(social)")
# parsimonious model where delta <2 and fewest predictors
# in this case only one model (the top ranked) delta AICc < 2
best1 <- get.models(dm1, delta <2)[[1]]
# check model
check_model(best1)
# summary
summary(best1)
# post-hoc comparison of slopes
emtrends(best1, pairwise ~ social, var = "elapsed")
# read in data and filter to reinforcement period
datam2 <- read.csv("results/daily_distance_between_roosts.csv") %>%
# add metadata
left_join(dplyr::select(metadata, c("id", "cohort"))) %>%
# format dates as dates
mutate(date = as_date(date)) %>%
# limit to reinforcement period
filter(date %in% rein_dates) %>%
# add a time elapsed post-release variable and scale it
mutate(elapsed = as.numeric(date - as_date("2023-06-10"))) %>%
# add column for membership to social group
mutate(social = ifelse(id %in% club, "Reinforcer - exclusive", ifelse(cohort == "Resident", "Resident", "Reinforcer - mixed"))) %>%
# convert group to factor and set resident as the intercept
mutate(social = factor(social, levels = c("Resident", "Reinforcer - mixed", "Reinforcer - exclusive"))) %>%
# exclude daisy
filter(!id == "Daisy")
# read in data and filter to reinforcement period
datam2 <- read.csv("results/daily_distance_between_roosts.csv") %>%
# add metadata
left_join(dplyr::select(metadata, c("id", "cohort"))) %>%
# format dates as dates
mutate(date = as_date(date)) %>%
# limit to reinforcement period
filter(date %in% rein_dates) %>%
# add a time elapsed post-release variable and scale it
mutate(elapsed = as.numeric(date - as_date("2023-06-10"))) %>%
# add column for membership to social group
mutate(social = ifelse(id %in% club, "Reinforcer - exclusive", ifelse(cohort == "Resident", "Resident", "Reinforcer - mixed"))) %>%
# convert group to factor and set resident as the intercept
mutate(social = factor(social, levels = c("Resident", "Reinforcer - mixed", "Reinforcer - exclusive"))) %>%
# exclude daisy
filter(!id == "Daisy")
# create social group means
sum2 <- datam2 %>%
group_by(date, social) %>%
summarise(dist = mean(distance_previous),
upper = dist + 1.96 * std.error(distance_previous),
lower = dist - 1.96 * std.error(distance_previous)) %>%
arrange(date)
# plot roost displacement over time as social group means
ggplot(sum2, aes(date, dist, ymin = lower, ymax = upper)) +
geom_path(aes(colour = social)) +
geom_ribbon(aes(fill = social), alpha = 0.2) +
xlab("Days post-reinforcement") +
ylab("Distance between consecutive roosts (m)") +
theme_minimal() +
scale_fill_viridis_d()+
scale_colour_viridis_d()
# test difference between the groups with interaction of time as a quadratic
m2 <- glmmTMB(log1p(distance_previous) ~ social * (scale(elapsed) + I(scale(elapsed)^2)) + (1|id),
data = datam2,
na.action = "na.fail")
# model selection
dm2 <- dredge(m2, fixed = "cond(social)")
# parsimonious model where delta <2 and fewest predictors
# in this case only two had delta <2 but top ranked was fewest
best2 <- get.models(dm2, delta <2)[[1]]
# summary
summary(best2)
# marginal effects
pred2 <- predict_response(best2, terms = c("elapsed [all]", "social"))
# plot predictions
ggplot(pred2, aes(x, predicted, fill = group, ymin = conf.low, ymax = conf.high)) +
geom_line(aes(colour = group))+
geom_ribbon(alpha = 0.2)+
xlab("Days post-reinforcement") +
ylab("Predicted values of roost displacement (m)") +
theme_minimal()+
scale_fill_viridis_d()+
scale_colour_viridis_d()
# post-hoc comparison of slopes
emtrends(best2, pairwise ~ social, var = "elapsed")
