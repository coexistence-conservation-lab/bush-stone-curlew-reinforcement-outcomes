geom_edge_fan(aes(alpha = weight)) +
geom_node_point(aes(colour = membership, size = centrality), show.legend = FALSE) +
theme_void()
# plot with ggraph
ggraph(res_tidy, layout = "fr") +
geom_edge_fan(aes(alpha = weight)) +
geom_node_point(aes(colour = membership, size = centrality), show.legend = FALSE) +
theme_void()
# set seed
set.seed(12345)
# plot with ggraph
ggraph(res_tidy, layout = "fr") +
geom_edge_fan(aes(alpha = weight)) +
geom_node_point(aes(colour = membership, size = centrality), show.legend = FALSE) +
theme_void()
# plot with ggraph
ggraph(res_tidy, layout = "fr") +
geom_edge_fan(aes(alpha = weight)) +
geom_node_point(aes(colour = membership, size = centrality), show.legend = FALSE) +
theme_void()
# plot with ggraph
ggraph(res_tidy, layout = "fr") +
geom_edge_fan(aes(alpha = weight)) +
geom_node_point(aes(colour = membership, size = centrality), show.legend = FALSE) +
theme_void()
# plot with ggraph
ggraph(res_tidy, layout = "fr") +
geom_edge_fan(aes(alpha = weight, linewidth = weight*0.1), show.legend = FALSE) +
geom_node_point(aes(colour = membership, size = centrality), show.legend = FALSE) +
theme_void()
# plot with ggraph
ggraph(res_tidy, layout = "fr") +
geom_edge_fan(aes(alpha = weight, linewidth = weight*0.05), show.legend = FALSE) +
geom_node_point(aes(colour = membership, size = centrality), show.legend = FALSE) +
theme_void()
View(res)
# summary statistics of contacts
hist(res$contacts)
# interaction list
res <- data_resident %>%
select(c(id, contact_id, contact)) %>%
group_by(id, contact_id) %>%
summarise(contacts = sum(contact)) %>%
# remove NAs
na.omit()
# summary statistics of contacts
hist(res$contacts)
mean(res$contacts)
sd(res$contacts)
summary(res$contacts)
# convert interaction to matrix
res2 <- data_resident %>%
select(c(id, contact_id, contact)) %>%
group_by(id, contact_id) %>%
summarise(contacts = sum(contact)) %>%
# remove NAs
na.omit()  %>%
# remove values <100 - this is the crucial difference
filter(contacts >100)
View(res2)
# convert interaction to matrix
res2 <- data_resident %>%
select(c(id, contact_id, contact)) %>%
group_by(id, contact_id) %>%
summarise(contacts = sum(contact)) %>%
# remove NAs
na.omit()  %>%
# remove values <100 - this is the crucial difference
filter(contacts >100) %>%
# add first bird to first bird comparison
rbind(data.frame(id = "Aurora", contact_id = "Aurora", contacts = 0)) %>%
# pivot to wide matrix
pivot_wider(names_from = contact_id, values_from = contacts, values_fill = 0) %>%
# convert bird id to row name labels
column_to_rownames("id") %>%
# move last column (from rbind) first
relocate(Aurora) %>%
# matrix
as.matrix()
# edge network from interaction matrix
res_graph <- graph_from_adjacency_matrix(res2, mode = "undirected", diag = FALSE, weighted = TRUE)
plot(res_graph)
plot(res_graph, edge.width = E(res_graph)$weight)
plot(res_graph, edge.width = E(res_graph)$weight/1000)
# convert interaction to matrix
res2 <- data_resident %>%
select(c(id, contact_id, contact)) %>%
group_by(id, contact_id) %>%
summarise(contacts = sum(contact)) %>%
# remove NAs
na.omit()  %>%
# remove values <100 - this is the crucial difference
filter(contacts >100) %>%
# scale contacts
mutate(contacts/1000)
View(res2)
# convert interaction to matrix
res2 <- data_resident %>%
select(c(id, contact_id, contact)) %>%
group_by(id, contact_id) %>%
summarise(contacts = sum(contact)) %>%
# remove NAs
na.omit()  %>%
# remove values <100 - this is the crucial difference
filter(contacts >100) %>%
# scale contacts
mutate(contatcs = contacts/1000)
# convert interaction to matrix
res2 <- data_resident %>%
select(c(id, contact_id, contact)) %>%
group_by(id, contact_id) %>%
summarise(contacts = sum(contact)) %>%
# remove NAs
na.omit()  %>%
# remove values <100 - this is the crucial difference
filter(contacts >100) %>%
# scale contacts
mutate(contacts = contacts/1000)
# convert interaction to matrix
res2 <- data_resident %>%
select(c(id, contact_id, contact)) %>%
group_by(id, contact_id) %>%
summarise(contacts = sum(contact)) %>%
# remove NAs
na.omit()  %>%
# remove values <100 - this is the crucial difference
filter(contacts >100) %>%
# scale contacts
mutate(contacts = contacts/1000) %>%
# add first bird to first bird comparison
rbind(data.frame(id = "Aurora", contact_id = "Aurora", contacts = 0)) %>%
# pivot to wide matrix
pivot_wider(names_from = contact_id, values_from = contacts, values_fill = 0) %>%
# convert bird id to row name labels
column_to_rownames("id") %>%
# move last column (from rbind) first
relocate(Aurora) %>%
# matrix
as.matrix()
# edge network from interaction matrix
res_graph <- graph_from_adjacency_matrix(res2, mode = "undirected", diag = FALSE, weighted = TRUE)
# plot with weighted edges
plot(res_graph, edge.width = E(res_graph)$weight/1000)
# plot with weighted edges
plot(res_graph, edge.width = E(res_graph)$weight)
comm <- cluster_walktrap(res_graph)
comm
# individual pairwise combinations
list <-combinations(n = length(residents), r = 2, v = residents, repeats.allowed = TRUE)
# list of residents
residents <- unique(data_resident$id)
l
# individual pairwise combinations
list <-combinations(n = length(residents), r = 2, v = residents, repeats.allowed = TRUE)
list1 <- list[,1]
list2 <- list[,2]
# loop through all birds to find number of points for potential interactions
exposure <- data.frame()
for(i in 1:length(list1)) {
bird1 <- filter(data_resident, id == list1[i])
bird2 <- filter(data_resident, id == list2[i])
# the start time is the later of the first timestamps
start <- max(c(min(bird1$time_local), min(bird2$time_local)))
# the end time is the earlier of the last timestamps
end <- min(c(max(bird1$time_local), max(bird2$time_local)))
# keep smaller of the number of fixes for the birds during the shared window
overlap <- data.frame(
bird1 = list1[i],
bird2 = list2[i],
overlap = as.integer(min(
nrow(filter(bird1, time_local > start & time_local <end)),
nrow(filter(bird2, time_local > start & time_local <end)))))
exposure <- rbind(exposure, overlap)
}
View(exposure)
# interaction list
res <- data_resident %>%
select(c(id, contact_id, contact)) %>%
group_by(id, contact_id) %>%
summarise(contacts = sum(contact)) %>%
# remove NAs
na.omit()
# add overlap data to contact table
res_assoc <- left_join(res, exposure)
# loop through all birds to find number of points for potential interactions
exposure <- data.frame()
for(i in 1:length(list1)) {
bird1 <- filter(data_resident, id == list1[i])
bird2 <- filter(data_resident, id == list2[i])
# the start time is the later of the first timestamps
start <- max(c(min(bird1$time_local), min(bird2$time_local)))
# the end time is the earlier of the last timestamps
end <- min(c(max(bird1$time_local), max(bird2$time_local)))
# keep smaller of the number of fixes for the birds during the shared window
overlap <- data.frame(
id = list1[i],
contact_id = list2[i],
overlap = as.integer(min(
nrow(filter(bird1, time_local > start & time_local <end)),
nrow(filter(bird2, time_local > start & time_local <end)))))
exposure <- rbind(exposure, overlap)
}
# add overlap data to contact table
res_assoc <- left_join(res, exposure)
View(res_assoc)
# individual pairwise combinations
list <-combinations(n = length(residents), r = 2, v = residents, repeats.allowed = FALSE)
list1 <- list[,1]
list2 <- list[,2]
# loop through all birds to find number of points for potential interactions
exposure <- data.frame()
for(i in 1:length(list1)) {
bird1 <- filter(data_resident, id == list1[i])
bird2 <- filter(data_resident, id == list2[i])
# the start time is the later of the first timestamps
start <- max(c(min(bird1$time_local), min(bird2$time_local)))
# the end time is the earlier of the last timestamps
end <- min(c(max(bird1$time_local), max(bird2$time_local)))
# keep smaller of the number of fixes for the birds during the shared window
overlap <- data.frame(
id = list1[i],
contact_id = list2[i],
overlap = as.integer(min(
nrow(filter(bird1, time_local > start & time_local <end)),
nrow(filter(bird2, time_local > start & time_local <end)))))
exposure <- rbind(exposure, overlap)
}
# add overlap data to contact table
res_assoc <- left_join(res, exposure)
View(res_assoc)
# individual pairwise combinations
list <-combinations(n = length(residents), r = 2, v = residents, repeats.allowed = TRUE)
list1 <- list[,1]
list2 <- list[,2]
# loop through all birds to find number of points for potential interactions
exposure <- data.frame()
for(i in 1:length(list1)) {
bird1 <- filter(data_resident, id == list1[i])
bird2 <- filter(data_resident, id == list2[i])
# the start time is the later of the first timestamps
start <- max(c(min(bird1$time_local), min(bird2$time_local)))
# the end time is the earlier of the last timestamps
end <- min(c(max(bird1$time_local), max(bird2$time_local)))
# keep smaller of the number of fixes for the birds during the shared window
overlap <- data.frame(
id = list1[i],
contact_id = list2[i],
overlap = as.integer(min(
nrow(filter(bird1, time_local > start & time_local <end)),
nrow(filter(bird2, time_local > start & time_local <end)))))
exposure <- rbind(exposure, overlap)
}
View(res)
# individual pairwise combinations
list <-combinations(n = 13, r = 2, v = residents, repeats.allowed = TRUE)
View(list)
?combinations
# individual pairwise combinations
list <-combinations(n = 13, r = 2, v = residents, set = FALSE, repeats.allowed = TRUE)
list1 <- list[,1]
list2 <- list[,2]
# individual pairwise combinations
list <-permutations(n = 13, r = 2, v = residents, set = FALSE, repeats.allowed = TRUE)
View(list)
# individual pairwise combinations
list <-permutations(n = 13, r = 2, v = residents, set = FALSE, repeats.allowed = FALSE)
# individual pairwise combinations
list <-permutations(n = 13, r = 2, v = residents, set = TRUE, repeats.allowed = FALSE)
View(list)
list1 <- list[,1]
list2 <- list[,2]
# loop through all birds to find number of points for potential interactions
exposure <- data.frame()
for(i in 1:length(list1)) {
bird1 <- filter(data_resident, id == list1[i])
bird2 <- filter(data_resident, id == list2[i])
# the start time is the later of the first timestamps
start <- max(c(min(bird1$time_local), min(bird2$time_local)))
# the end time is the earlier of the last timestamps
end <- min(c(max(bird1$time_local), max(bird2$time_local)))
# keep smaller of the number of fixes for the birds during the shared window
overlap <- data.frame(
id = list1[i],
contact_id = list2[i],
overlap = as.integer(min(
nrow(filter(bird1, time_local > start & time_local <end)),
nrow(filter(bird2, time_local > start & time_local <end)))))
exposure <- rbind(exposure, overlap)
}
# add overlap data to contact table
res_assoc <- left_join(res, exposure)
for(i in 1:length(list1)) {
bird1 <- filter(data_resident, id == list1[i])
bird2 <- filter(data_resident, id == list2[i])
# the start time is the later of the first timestamps
start <- max(c(min(bird1$time_local), min(bird2$time_local)))
# the end time is the earlier of the last timestamps
end <- min(c(max(bird1$time_local), max(bird2$time_local)))
# keep smaller of the number of fixes for the birds during the shared window
overlap <- data.frame(
id = list1[i],
contact_id = list2[i],
overlap = as.integer(min(
nrow(filter(bird1, time_local > start & time_local <end)),
nrow(filter(bird2, time_local > start & time_local <end)))))
exposure <- rbind(exposure, overlap)
}
View(overlap)
# loop through all birds to find number of points for potential interactions
exposure <- data.frame()
for(i in 1:length(list1)) {
bird1 <- filter(data_resident, id == list1[i])
bird2 <- filter(data_resident, id == list2[i])
# the start time is the later of the first timestamps
start <- max(c(min(bird1$time_local), min(bird2$time_local)))
# the end time is the earlier of the last timestamps
end <- min(c(max(bird1$time_local), max(bird2$time_local)))
# keep smaller of the number of fixes for the birds during the shared window
overlap <- data.frame(
id = list1[i],
contact_id = list2[i],
overlap = as.integer(min(
nrow(filter(bird1, time_local > start & time_local <end)),
nrow(filter(bird2, time_local > start & time_local <end)))))
exposure <- rbind(exposure, overlap)
}
# add overlap data to contact table
res_assoc <- left_join(res, exposure)
# add overlap data to contact table
res_assoc <- left_join(res, exposure) %>%
# calculate assocation
mutate(association = contacts/overlap)
View(res_assoc)
View(data)
# Read in cleaned data
data <- read.csv("data/data_cleaned.csv") %>%
# Time in posix format
mutate(time_local = as.POSIXct(time_local, format = "%Y-%m-%d %H:%M:%OS",
tz = "Australia/Melbourne")) %>%
# Add date
mutate(date = as_date(time_local, tz = "Australia/Melbourne")) %>%
# drop birds excluded from analyses
filter(!id %in% c("Wobbles", "Star")) %>%
# drop NAs
na.omit()
# format track data as move2 object
move <- mt_as_move2(data, coords = c("easting", "northing"), time_column = "time_local", track_id_column = "id") %>%
# add crs
sf::st_set_crs("EPSG:32755") %>%
# needed to omit NAs for conProcess to work
na.omit()
# define resident only date period
res_dates <- seq.Date(from = as_date("2023-01-16"), to = as_date("2023-06-06"), by = "day")
# subset to dates
data_resident <- data %>%
filter(date %in% res_dates)
# list of residents
residents <- unique(data_resident$id)
# All bird combinations
list <-combinations(n = 13, r = 2, v = residents, repeats.allowed = FALSE)
list1 <- list[,1]
list2 <- list[,2]
View(list)
data.frame(
prox = Prox(move[list1[i]], move[list2[i]], tc=4*60, dc=30),
prox = Prox(move[list1[i]], move[list2[i]], tc=4*60, dc=30),
bird1 = list1[i],
bird2 = list2[i])
# Calculate interactions between all birds 🐢🐢
interact <- data.frame()
for(i in 1:length(list1)) {
temp <- tryCatch({
data.frame(
prox = Prox(move[list1[i]], move[list2[i]], tc=4*60, dc=30),
di = DI(move[list1[i]], move[list2[i]], tc=4*60),
bird1 = list1[i],
bird2 = list2[i])
}, error = function(e) data.frame(iab = NA, bird1 = NA, bird2 = NA))
print(paste("Finished",i))
interact <- rbind(interact, temp)
}
View(interact)
for(i in 1:length(list1)) {
temp <- tryCatch({
data.frame(
prox = Prox(move[list1[i]], move[list2[i]], tc=4*60, dc=30),
di = DI(move[list1[i]], move[list2[i]], tc=4*60),
bird1 = list1[i],
bird2 = list2[i])
}, error = function(e) data.frame(iab = NA, bird1 = NA, bird2 = NA))
print(paste("Finished",i))
interact <- rbind(interact, temp)
}
# Calculate interactions between all birds 🐢🐢
interact <- data.frame()
for(i in 1:length(list1)) {
temp <- tryCatch({
data.frame(
prox = Prox(move[list1[i]], move[list2[i]], tc=4*60, dc=30),
di = DI(move[list1[i]], move[list2[i]], tc=4*60),
bird1 = list1[i],
bird2 = list2[i])
}, error = function(e) data.frame(iab = NA, bird1 = NA, bird2 = NA))
print(paste("Finished",i))
interact <- rbind(interact, temp)
}
temp <- data.frame(
prox = Prox(move[list1[i]], move[list2[i]], tc=4*60, dc=30),
di = DI(move[list1[i]], move[list2[i]], tc=4*60),
bird1 = list1[i],
bird2 = list2[i])
temp <- data.frame(
prox = Prox(move[list1[i]], move[list2[i]], tc=4*60, dc=30),
di = DI(move[list1[i]], move[list2[i]], tc=4*60),
bird1 = list1[i],
bird2 = list2[i])
# Calculate interactions between all birds 🐢🐢
interact <- data.frame()
for(i in 1:length(list1)) {
temp <- data.frame(
prox = Prox(move[list1[i]], move[list2[i]], tc=4*60, dc=30),
di = DI(move[list1[i]], move[list2[i]], tc=4*60),
bird1 = list1[i],
bird2 = list2[i])
print(paste("Finished",i))
interact <- rbind(interact, temp)
}
# define resident only date period
res_dates <- seq.Date(from = as_date("2023-01-16"), to = as_date("2023-06-06"), by = "day")
# subset to dates
data_resident <- move %>%
filter(date %in% res_dates)
# list of residents
residents <- unique(data_resident$id)
# All bird combinations
list <-combinations(n = 13, r = 2, v = residents, repeats.allowed = FALSE)
list1 <- list[,1]
list2 <- list[,2]
# Calculate interactions between all birds 🐢🐢
interact <- data.frame()
for(i in 1:length(list1)) {
temp <- data.frame(
prox = Prox(move[list1[i]], move[list2[i]], tc=4*60, dc=30),
di = DI(move[list1[i]], move[list2[i]], tc=4*60),
bird1 = list1[i],
bird2 = list2[i])
print(paste("Finished",i))
interact <- rbind(interact, temp)
}
for(i in 1:length(list1)) {
temp <- data.frame(
prox = Prox(data_resident[list1[i]], data_resident[list2[i]], tc=4*60, dc=30),
di = DI(data_resident[list1[i]], data_resident[list2[i]], tc=4*60),
bird1 = list1[i],
bird2 = list2[i])
print(paste("Finished",i))
interact <- rbind(interact, temp)
}
paste("Finished", list1[i], "&", list2[i], "(", i, "of 78)", sep = " "
)
View(data_resident)
bird1 <- filter(data_resident, id == list1[1])
View(bird1)
# Calculate interactions between all birds 🐢🐢
interact <- data.frame()
for(i in 1:length(list1)) {
bird1 <- filter(data_resident, id == list1[i])
bird2 <- filter(data_resident, id == list2[i])
temp <- data.frame(
prox = Prox(bird1, bird2, tc=4*60, dc=30),
di = DI(bird1, bird2, tc=4*60),
bird1 = list1[i],
bird2 = list2[i])
print(paste("Finished", list1[i], "&", list2[i], i, "of 78", sep = " "))
interact <- rbind(interact, temp)
}
View(interact)
# subset to dates
data_resident <- move %>%
filter(date %in% res_dates)
# Calculate interactions between all birds 🐢🐢
interact <- data.frame()
for(i in 1:length(list1)) {
bird1 <- filter(data_resident, id == list1[i])
bird2 <- filter(data_resident, id == list2[i])
temp <- tryCatch({
data.frame(
prox = Prox(bird1, bird2, tc=4*60, dc=30),
di = DI(bird1, bird2, tc=4*60),
bird1 = list1[i],
bird2 = list2[i])
}, error = function(e) data.frame(iab = NA, bird1 = NA, bird2 = NA))
print(paste("Finished", list1[i], "&", list2[i], i, "of 78", sep = " "))
interact <- rbind(interact, temp)
}
View(interact)
move
# Test for a single dyad
dyad <- filter(move, id %in% c("Aurora", "Briar"))
dyad
checkTO(dyad)
# Test for a single dyad
dyad <- filter(move, id %in% c(list1[i], "Briar"))
dyad
checkTO(dyad)
test <- data.frame(
prox = Prox(dyad, tc=4*60, dc=30),
di = DI(dyad, tc=4*60))
test <- prox = Prox(dyad, tc=4*60, dc=30)
test <- prox = Prox(dyad, tc=4*60, dc=30)
test <- Prox(dyad, tc=4*60, dc=30)
test
