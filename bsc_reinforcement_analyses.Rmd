---
title: "bsc_reinforcement_analyses"
author: "Shoshana Rapley"
date: "`r Sys.Date()`"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

# Packages
pacman::p_load(atlastools, beepr, janitor, ggmap, sf, terra, tidyterra, tidyverse)

# Google API key for ggmaps
ggmap::register_google(key = readChar("apikey_google.txt", nchars = file.info("apikey_google.txt")$size))

# Background map MR zones 1 and 2
map_z13 <- get_map(c(144.4380, -37.9000), zoom=13, maptype = "satellite")
map_z14 <- get_map(c(144.4380, -37.9000), zoom=14, maptype = "satellite")
map_z15 <- get_map(c(144.4380, -37.9000), zoom=15, maptype = "satellite")
```

# Introduction

Reinforcement is a form of conservation translocation used to stabilise or enhance populations. Reinforcement is also a stage within other forms of translocation, which usually involve multiple release cohorts. Even a reintroduction project will have conspecifics present from the second release. Benefits of reinforcing release are assumed (e.g., increase population size, add diversity) but rarely empirically tested â€“ and if they are its usually from perspective of reinforcing individuals, not the population as a whole. Outcomes of reinforcement are mediated by social interactions, which are also assumed but not often empirically tested. 

Here we test the outcomes of reinforcement for a population of bush stone-curlew where all individuals in the population (previously released and reinforcing) are accounted for and tracked with GPS. We ask: do the cohorts integrate? And do social interactions benefit the reinforcing cohort? 

# Data cleaning

We translocated 36 adult captive-bred bush stone-curlews from Mt Rothwell captive colony to Mt Rothwell Zone 1 (fenced sanctuary) in two stages. The first (pilot) cohort of 16 birds was released between October 2022 and June 2023. The second (reinforcing) cohort of 20 birds was released in June 2023. 

All translocated birds were fitted with a GPS tracker (Ornitrak20 from Ornitela) with a duty cycle of a fix every 60 seconds (or reduced when battery low). Telemetry data were stored on Movebank. We collected data from the release date of each individual until the 12th of January 2024 (when GPS devices were removed from all remaning birds except one, ahead of the 3G shutdown).

High throughput animal tracking data require filtering to remove erroneous points, while maintaining real movement data. We follow the workflow by [Gupte et al. (2021)](https://besjournals.onlinelibrary.wiley.com/doi/full/10.1111/1365-2656.13610), that is:

1) temporal filtering (mostly done on Movebank by setting deployment period)
2) filtering by quality covariates
3) filtering biologically unrealistic movement
4) median smoothing

## Test pipeline

We first tested the pipeline with a subset of the data (birds "Marmalade" & "Fauna"). Marmalade left the fenced area during the study while Fauna did not. 

### 1) Temporal filtering

We removed points after the end of the study period. 

```{r}
# import data from movebank
test1 <- readr::read_csv("movebank/Fauna01.csv", show_col_types = FALSE) %>%
  rbind(readr::read_csv("movebank/Marmalade01.csv", show_col_types = FALSE)) %>%
  clean_names() %>%
  # Time in posix format
  mutate(datetime = as.POSIXct(study_local_timestamp, "%Y-%m-%d %H:%M:%S"),
         date = as.Date(datetime)) %>%
  # Remove days after end of tracking period - for Marmalade whose GPS not removed
  filter(date < "2024-01-12") %>%
  rename(id = individual_local_identifier)

# plot raw data
ggmap(map_z13)+
  geom_path(data=test1, aes(location_long, location_lat), 
            colour = "yellow", alpha = .6)+
  geom_point(data=test1, aes(location_long, location_lat), 
             colour = "yellow", alpha = .6)+
  theme_void()+
  facet_wrap(~id)
```

### 2) Filtering by quality covariates

In the past I've found filtering by satellite count and hdop has a high rate of false positives (removing real movement) and low rate of true positives (removing unrealistic movement) so we don't want to be overly aggressive with the application of these filters.

```{r}
# Histogram of satellite vales
hist(test1$gps_satellite_count)

# Plot track, colour by satellite values
ggmap(map_z13)+
  geom_path(data=test1, aes(location_long, location_lat), colour = "white")+
  geom_point(data=test1, aes(location_long, location_lat, colour = gps_satellite_count))+
  scale_colour_viridis_c()+
  theme_void()+
  facet_wrap(~id)
```

Most points have a satellite count >=4. Not many of the obvious spikes have low satellite count. We'll filter to include only satellite count >=4. 

```{r}
# Histogram of satellite vales
hist(test1$gps_hdop)

# Plot track, colour by hdop values
ggmap(map_z13)+
  geom_path(data=test1, aes(location_long, location_lat), colour = "white")+
  geom_point(data=test1, aes(location_long, location_lat, colour = gps_hdop))+
  scale_colour_viridis_c()+
  theme_void()+
  facet_wrap(~id)
```

There are a handful of massive hdop values (5-15) but the vast majority are =<2. Again the obvious spikes don't have high hdop values. We'll filter to only include hdop <=2. 

Whereas I've found better filtering on the basis of altitude. 

Incorrect GPS fixes often have incorrect altitude. High altitude was not expected as no birds were undertaking long-distance flight, which is the only time high altitude is possible. All birds were wing-clipped on release and some later moulted and undertook short-distance flight, but not at high altitude. 

First we need to find flight height altitude by correcting for ground elevation. We are using the [FABDEM (Forest And Buildings removed Copernicus 30m DEM)](https://gee-community-catalog.org/projects/fabdem/).

```{r}
# read in FABDEM
fabdem <- rast("S38E144_FABDEM_V1-0.tif") 

# convert data to spatial points
coords <- test1 %>%
  vect(geom = c("location_long", "location_lat"), crs = "EPSG:4326")

# Extract dem and add to dataframe
test2 <- test1 %>%
  mutate(terra::extract(fabdem, coords, ID = FALSE)) %>%
  rename(elevation = "S38E144_FABDEM_V1-0") %>%
  # calculate flight height
  mutate(altitude = height_above_msl - elevation)

# Histogram altitude
hist(test2$altitude)

# Summary statistics altitude
summary(test2$altitude)
quantile(test2$altitude, probs = 0.95)

# Plot track, colour by altitude values
ggmap(map_z13)+
  geom_path(data=test2, aes(location_long, location_lat), colour = "white")+
  geom_point(data=test2, aes(location_long, location_lat, colour = altitude))+
  scale_colour_viridis_c()+
  theme_void()+
  facet_wrap(~id)
```

The median altitude (above the ground) was 9m. The min (-2060m) and max (8313m) altitude were considered unrealistic. Most of the data that looks real is at ground altitude. Many of the obvious spikes have high or low altitude. 

We cut off the maximum altitude at 60 (just above the 0.95 quartile) and the minimum to -10m (ground level allowing for some error).

```{r}
# Apply quality covariate filters
test2 <- test2 %>%
  filter(gps_satellite_count >= 4) %>%
  filter(gps_hdop <=2) %>%
  filter(altitude < 60 & altitude >-10)

# Plot effect of filtering
ggmap(map_z13)+
  geom_path(data=test1, aes(location_long, location_lat), 
            colour = "purple", alpha = .6)+
  geom_point(data=test1, aes(location_long, location_lat), 
             colour = "yellow")+
  geom_point(data=test2, aes(location_long, location_lat), 
             colour = "purple")+
  theme_void()+
  facet_wrap(~id)
```

This successfully filtered out most of the obvious spikes.

### 3) Filtering biologically unrealistic movement

To remove spikes in the data we can filter out positions with extreme incoming and outgoing speeds. First we need to define biologically realistic incoming and outgoing speeds.

```{r}
# Append turning angle, incoming/outgoing speeds to data frame per bird
birds <- unique(test1$id)

test3 <- data.frame()

for(i in 1:length(birds)){
 subset <- filter(test2, id == birds[i])

 temp <- subset %>%
   mutate(speed_in  = atl_get_speed(
    data = subset, x = "utm_easting", y = "utm_northing", time = "datetime", type = c("in")),
         speed_out = atl_get_speed(
           data = subset, x = "utm_easting", y = "utm_northing", time = "datetime", type = c("out")),
         angle = atl_turning_angle(
           data = subset, x = "utm_easting", y = "utm_northing", time = "datetime"))
 
 test3 <- rbind(test3, temp)
}

# Histogram incoming speeds
hist(test3$speed_in)

# Summary statistics incoming speeds
summary(test3$speed_in)
quantile(test3$speed_in, probs = 0.99, na.rm = TRUE)

# Histogram outgoing speeds
hist(test3$speed_out)

# Summary statistics outgoing speeds
summary(test3$speed_out)
quantile(test3$speed_out, probs = 0.99, na.rm = TRUE)

# Histogram turning angle
hist(test3$angle)

# Summary statistics turning angle
summary(test3$angle)

# Plot track, colour by speed
ggmap(map_z14)+
  geom_path(data=test3, aes(location_long, location_lat), colour = "white")+
  geom_point(data=test3, aes(location_long, location_lat, colour = speed_in))+
  scale_colour_viridis_c()+
  theme_void()+
  facet_wrap(~id)
```

Speeds were usually <2m/s and outgoing speeds while turning are likely <1m/s. A sharp turning angle was defined as <90 degrees. 

We defined biologically realistic movement as speeds <2m/s (a note of caution: this shouldn't be used when the birds are undertaking long distance movements as faster speeds may be possible e.g. while gliding on wind) and turning speeds of 1m/s. 

```{r}
# Apply turning angle filtering
test3 <- test3 %>%
  filter(speed_in < 2) %>%
  filter(!(speed_out >1 & angle <90))

# Plot effect of filtering
ggmap(map_z14)+
  geom_path(data=test1, aes(location_long, location_lat), 
            colour = "purple", alpha = .6)+
  geom_point(data=test1, aes(location_long, location_lat), 
             colour = "yellow")+
  geom_point(data=test2, aes(location_long, location_lat), 
             colour = "orange")+
  geom_point(data=test3, aes(location_long, location_lat), 
             colour = "purple")+
  theme_void()+
  facet_wrap(~id)
```

### 4) Spatial filtering

We know Fauna didn't leave the study site during the tracking period but there are points over the fence that have not been removed. So what covariates do these incorrect points have in common? 

First define the fenced area.

```{r}
# Define fence polygons (zones 1 and 2)
mtr <- rbind(
  ## zone 1
  c(-37.897319, 144.429048), # S end of NW diagonal
  c(-37.894066, 144.432334), # N end of NW diagonal, i.e. NW corner
  c(-37.894749, 144.438305), # bend at main gate 
  c(-37.894693, 144.438324), # main gate
  c(-37.894803, 144.439214), # bend before N Z1/2 gate
  c(-37.894718, 144.439337), # N Z1/2 gate, i.e. NE corner 
  ## zone 2
  c(-37.892433, 144.440236), # N boundary internal aviary/Z2 i.e. NW corner
  c(-37.892803, 144.443374), # Z2 northern boundary bend 1
  c(-37.893634, 144.444076), # Z2 northern boundary bend 2
  c(-37.894585, 144.447739), # N end of Z2/Z3 boundary, i.e. NE corner
  c(-37.896515, 144.446789), # Z2/Z3 boundary bend 1
  c(-37.896726, 144.446099), # Z2/Z3 boundary bend 2
  c(-37.897964, 144.445706), # Z2/Z3 boundary bend 3
  c(-37.899960, 144.444517), # S end of Z2/Z3 boundary, i.e. SE corner
  c(-37.899908, 144.444288), # Z2/btrw NE corner
  c(-37.898280, 144.440662), # Z1/btrw pen NW corner
  ## zone 1
  c(-37.900692, 144.440368), # Z1/btrw SW corner
  c(-37.902610, 144.443002), # Z1/btrw SE corner
  c(-37.909538, 144.439648), # Z1 SE corner
  c(-37.908999, 144.434965), # Z1 southern boundary bend 1
  c(-37.907537, 144.433359), # Z1 southern boundary bend 2
  c(-37.905958, 144.430140), # Z1 southern boundary bend 3
  c(-37.905486, 144.429479), # Z1 southern boundary bend 4
  c(-37.904649, 144.427566), # Z1 SW corner
  c(-37.897319, 144.429048)  # S end of NW diagonal
  ) %>%  vect(type = "polygons", crs = "EPSG:4326") %>% t() %>%
  # add a buffer for GPS accuracy of 30m
  buffer(30)
```

Then filter for points from "Fauna" outside of the polygon. 

```{r}
# Convert df to points
points <- test3 %>%
  filter(id=="Fauna") %>%
  vect(geom = c("location_long", "location_lat"), crs = "EPSG:4326")

# Find points outside polygons
outside <- points[!relate(points, mtr, "intersects")] %>%
  as.data.frame(geom = "XY")
  
# Plot points outside polygon 
ggmap(map_z15)+
  geom_point(data=outside, aes(x, y, colour = speed_out), size = 2)+
  geom_spatvector(data=mtr, inherit.aes = FALSE, colour = "white", fill = NA)+
  scale_colour_viridis_c()+
  theme_void()
```


### 4) Median smoothing

Even after speed/angle filtering, we retain some smaller-scale 'jitter'- these are challenging to remove as they lie within the bounds of realistic movement. Median resampling is a method of smoothing the track to reduce jitter. We want to apply it sparingly to not reduce track verismilitude.

```{r}
# Apply median smooth
test4 <- atl_median_smooth(data = test3, x = "location_lat", y = "location_long",
                                  time = "datetime", moving_window = 3)

# Plot effect of smoothing
ggmap(map_z13)+
  geom_path(data=test1, aes(location_long, location_lat), 
            colour = "yellow", alpha = .6)+
    geom_path(data=test4, aes(location_long, location_lat), 
            colour = "purple", alpha = .7)

# Zoom in to smoothed track
ggmap(map_z15)+
    geom_path(data=test4, aes(location_long, location_lat), 
            colour = "purple", alpha = .7)
```

## Clean data

Apply the cleaning pipeline to all birds in this study.

```{r}
# import data from movebank
test1 <- readr::read_csv(fs::dir_ls(path = "Input/movebank"), show_col_types = FALSE) %>%
  clean_names() %>%
  # Time in posix format
  mutate(datetime = as.POSIXct(study_local_timestamp, "%Y-%m-%d %H:%M:%S"),
         date = as.Date(datetime)) %>%
  # Remove days after end of tracking period - for Marmalade whose GPS not removed
  filter(date < "2024-01-12")
```


