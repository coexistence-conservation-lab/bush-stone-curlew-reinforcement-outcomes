---
title: "bsc_reinforcement_analyses"
author: "Shoshana Rapley"
date: "`r Sys.Date()`"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

# Packages
pacman::p_load(amt, atlastools, beepr, ggfortify, ggmap, ggpubr, ggridges, janitor, lme4, lmerTest, move, scattermore, sf, suncalc, survival, survminer, terra, tidyterra, tidyverse)

# Google API key for ggmaps
ggmap::register_google(key = readChar("apikey_google.txt", nchars = file.info("apikey_google.txt")$size))

# Background map MR zones 1 and 2
map_z13 <- get_map(c(144.4380, -37.9000), zoom=13, maptype = "satellite")
map_z14 <- get_map(c(144.4380, -37.9000), zoom=14, maptype = "satellite")
map_z15 <- get_map(c(144.4380, -37.9000), zoom=15, maptype = "satellite")

# Metadata - translocation information
metadata  <- read.csv("data/metadata.csv") %>%
  clean_names() %>%
  rename(id = identity,
         mortality = mortality_or_capture) %>%
  mutate(start_date = as_date(dmy(start_date)),
         end_date = as_date(dmy(end_date)),
         mortality = as_date(dmy(mortality)))
```

# Introduction

Reinforcement is a form of conservation translocation used to stabilise or enhance populations. Reinforcement is also a stage within other forms of translocation, which usually involve multiple release cohorts. Even a reintroduction project will have conspecifics present from the second release. Benefits of reinforcing release are assumed (e.g., increase population size, add diversity) but rarely empirically tested â€“ and if they are its usually from perspective of reinforcing individuals, not the population as a whole. Outcomes of reinforcement are mediated by social interactions, which are also assumed but not often empirically tested. 

Here we test the outcomes of reinforcement for a population of bush stone-curlew where all individuals in the population (previously released and reinforcing) are accounted for and tracked with GPS. We ask: do the cohorts integrate? And do social interactions benefit the reinforcing cohort? 

# Data cleaning

We translocated 36 adult captive-bred bush stone-curlews from Mt Rothwell captive colony to Mt Rothwell Zone 1 (fenced sanctuary) in two stages. The first (pilot) cohort of 16 birds was released between October 2022 and June 2023. The second (reinforcing) cohort of 20 birds was released in June 2023. 

All translocated birds were fitted with a GPS tracker (Ornitrak20 from Ornitela) with a duty cycle of a fix every 60 seconds (or reduced when battery low). Telemetry data were stored on Movebank. We collected data from the release date of each individual until the 12th of January 2024 (when GPS devices were removed from all remaning birds except one, ahead of the 3G shutdown).

High throughput animal tracking data require filtering to remove erroneous points, while maintaining real movement data. We follow the workflow by [Gupte et al. (2021)](https://besjournals.onlinelibrary.wiley.com/doi/full/10.1111/1365-2656.13610), that is:

1) temporal filtering (mostly done on Movebank by setting deployment period)
2) filtering by quality covariates
3) filtering biologically unrealistic movement
4) median smoothing

## Test pipeline

We first tested the pipeline with a subset of the data (birds "Marmalade" & "Fauna"). Marmalade left the fenced area during the study while Fauna did not. 

### 1) Temporal filtering

We removed points after the end of the study period (4/8/23 at the start of next experiment - translocation to Orana).

```{r}
# import data from movebank
data_raw <- readr::read_csv("movebank/Fauna01.csv", show_col_types = FALSE) %>%
  rbind(readr::read_csv("movebank/Marmalade01.csv", show_col_types = FALSE)) %>%
  clean_names() %>%
  # Time in posix format
  mutate(datetime = as.POSIXct(study_local_timestamp, "%Y-%m-%d %H:%M:%S"),
         date = as.Date(datetime)) %>%
  # Remove days after end of tracking period
  filter(date < "2023-08-04") %>%
  rename(id = individual_local_identifier)

# plot raw data
ggmap(map_z13)+
  geom_path(data=data_raw, aes(location_long, location_lat), 
            colour = "yellow", alpha = .6)+
  geom_point(data=data_raw, aes(location_long, location_lat), 
             colour = "yellow", alpha = .6)+
  theme_void()+
  facet_wrap(~id)
```

### 2) Filtering by quality covariates

In the past I've found filtering by satellite count and hdop has a high rate of false positives (removing real movement) and low rate of true positives (removing unrealistic movement) so we don't want to be overly aggressive with the application of these filters.

```{r}
# Histogram of satellite vales
hist(data_raw$gps_satellite_count)

# Plot track, colour by satellite values
ggmap(map_z13)+
  geom_path(data=data_raw, aes(location_long, location_lat), colour = "white")+
  geom_point(data=data_raw, aes(location_long, location_lat, colour = gps_satellite_count))+
  scale_colour_viridis_c()+
  theme_void()+
  facet_wrap(~id)
```

Most points have a satellite count >=4. Not many of the obvious spikes have low satellite count. We'll filter to include only satellite count >=4. 

Now look at the horizontal dilution of precision (HDOP).

```{r}
# Histogram of hdop vales
hist(data_raw$gps_hdop)

# Plot track, colour by hdop values
ggmap(map_z13)+
  geom_path(data=data_raw, aes(location_long, location_lat), colour = "white")+
  geom_point(data=data_raw, aes(location_long, location_lat, colour = gps_hdop))+
  scale_colour_viridis_c()+
  theme_void()+
  facet_wrap(~id)
```

There are a handful of massive hdop values (5-15) but the vast majority are =<2. Again the obvious spikes don't have high hdop values. We'll filter to only include hdop <=2. 

Whereas I've found better filtering on the basis of altitude. 

Incorrect GPS fixes often have incorrect altitude. High altitude was not expected as no birds were undertaking long-distance flight, which is the only time high altitude is possible. All birds were wing-clipped on release and some later moulted and undertook short-distance flight, but not at high altitude. 

First we need to find flight height altitude by correcting for ground elevation. We are using the [FABDEM (Forest And Buildings removed Copernicus 30m DEM)](https://gee-community-catalog.org/projects/fabdem/).

```{r}
# read in FABDEM
fabdem <- rast("S38E144_FABDEM_V1-0.tif") 

# convert data to spatial points
coords <- data_raw %>%
  vect(geom = c("location_long", "location_lat"), crs = "EPSG:4326")

# Extract dem and add to dataframe
data_alt <- data_raw %>%
  mutate(terra::extract(fabdem, coords, ID = FALSE)) %>%
  rename(elevation = "S38E144_FABDEM_V1-0") %>%
  # calculate flight height
  mutate(altitude = height_above_msl - elevation)

# Histogram altitude
hist(data_alt$altitude)

# Summary statistics altitude
summary(data_alt$altitude)
quantile(data_alt$altitude, probs = 0.95)

# Plot track, colour by altitude values
ggmap(map_z13)+
  geom_path(data=data_alt, aes(location_long, location_lat), colour = "white")+
  geom_point(data=data_alt, aes(location_long, location_lat, colour = altitude))+
  scale_colour_viridis_c()+
  theme_void()+
  facet_wrap(~id)
```

The median altitude (above the ground surface) was 9m. The min (-2060m) and max (8313m) altitude were considered unrealistic. Many of the obvious spikes have very high or negative altitude. 

We cut off the maximum altitude at 60 (just above the 0.95 quartile) and the minimum to -10m (ground level allowing for some error).

```{r}
# Apply quality covariate filters
data_qfilt <- data_alt %>%
  filter(gps_satellite_count >= 4) %>%
  filter(gps_hdop <=2) %>%
  filter(altitude < 60 & altitude >-10)

# Plot effect of filtering
ggmap(map_z13)+
  geom_path(data=data_raw, aes(location_long, location_lat), 
            colour = "purple", alpha = .6)+
  geom_point(data=data_raw, aes(location_long, location_lat), 
             colour = "yellow")+
  geom_point(data=data_qfilt, aes(location_long, location_lat), 
             colour = "purple")+
  theme_void()+
  facet_wrap(~id)
```

This successfully filtered out most of the obvious spikes.

### 3) Filtering biologically unrealistic movement

To remove spikes in the data we can filter out positions with extreme incoming and outgoing speeds. First we need to define biologically realistic incoming and outgoing speeds.

```{r}
# Append turning angle, incoming/outgoing speeds to data frame per bird
birds <- unique(data_raw$id)

data_speed <- data.frame()

for(i in 1:length(birds)){
 subset <- filter(data_qfilt, id == birds[i])

 temp <- subset %>%
   mutate(speed_in  = atl_get_speed( 
           data = subset, x = "utm_easting", y = "utm_northing", time = "datetime", type = c("in")),
    speed_out = atl_get_speed(
           data = subset, x = "utm_easting", y = "utm_northing", time = "datetime", type = c("out")),
    angle = atl_turning_angle(
           data = subset, x = "utm_easting", y = "utm_northing", time = "datetime"),
    speed_delta = abs(speed_in - speed_out)
    )
 
 data_speed <- rbind(data_speed, temp)
}

# Histogram incoming speeds
hist(data_speed$speed_in)

# Summary statistics incoming speeds
summary(data_speed$speed_in)
quantile(data_speed$speed_in, probs = 0.99, na.rm = TRUE)

# Histogram outgoing speeds
hist(data_speed$speed_out)

# Summary statistics outgoing speeds
summary(data_speed$speed_out)
quantile(data_speed$speed_out, probs = 0.95, na.rm = TRUE)

# Histogram turning angle
hist(data_speed$angle)

# Summary statistics turning angle
summary(data_speed$angle)

# Histogram difference between incoming and outgoing speed
hist(data_speed$speed_delta)

# Summary statistics difference between incoming and outgoing speed
summary(data_speed$speed_delta)
quantile(data_speed$speed_delta, probs = 0.95, na.rm = TRUE)

# Plot track, colour by speed
ggmap(map_z14)+
  geom_path(data=data_speed, aes(location_long, location_lat), colour = "white")+
  geom_point(data=data_speed, aes(location_long, location_lat, colour = speed_delta))+
  scale_colour_viridis_c()+
  theme_void()+
  facet_wrap(~id)
```

Speeds were usually <2m/s and outgoing speeds while turning are likely <1m/s. A sharp turning angle was defined as <90 degrees. Sharp increase/decrease in speed also isn't expected, with the vast majority of difference between incoming and outgoing speed 0.1m/s.

We defined biologically realistic movement as speeds <2m/s (a note of caution: this shouldn't be used when the birds are undertaking long distance movements as faster speeds may be possible e.g. while gliding on wind), turning speeds of 0.5m/s, and delta speed as 0.4m/s. 

```{r}
# Apply turning angle filtering
data_sfilt <- data_speed %>%
  filter(speed_in < 2) %>%
  filter(speed_delta < 0.4) %>%
  filter(!(speed_out >0.5 & angle <90))

# Plot effect of filtering
ggmap(map_z14)+
  geom_path(data=data_raw, aes(location_long, location_lat), 
            colour = "purple", alpha = .6)+
  geom_point(data=data_raw, aes(location_long, location_lat), 
             colour = "yellow")+
  geom_point(data=data_qfilt, aes(location_long, location_lat), 
             colour = "orange")+
  geom_point(data=data_sfilt, aes(location_long, location_lat), 
             colour = "purple")+
  theme_void()+
  facet_wrap(~id)
```

### 4) Median smoothing

Even after speed/angle filtering, we retain some smaller-scale 'jitter'- these are challenging to remove as they lie within the bounds of realistic movement. Median resampling is a method of smoothing the track to reduce jitter. We want to apply it sparingly to not reduce track verismilitude.

```{r}
# Apply median smooth by bird
data_smooth <- data.frame()

for(i in 1:length(birds)){
  
  subset <- filter(data_sfilt, id == birds[i])
  
  temp <- atl_median_smooth(data = subset, x = "location_lat", y = "location_long",
                                  time = "datetime", moving_window = 3)
  
  data_smooth <- rbind(data_smooth, temp)
}

# Plot effect of smoothing
ggmap(map_z13)+
  geom_path(data=data_raw, aes(location_long, location_lat), 
            colour = "yellow", alpha = .6)+
  geom_path(data=data_smooth, aes(location_long, location_lat), 
            colour = "purple", alpha = .7)+
  facet_wrap(~id)

# And zoom in to the fenced area
ggmap(map_z15)+
  geom_path(data=data_raw, aes(location_long, location_lat), 
            colour = "yellow", alpha = .6)+
  geom_path(data=data_smooth, aes(location_long, location_lat), 
            colour = "purple", alpha = .7)+
  facet_wrap(~id)

# And visualise without filtered out data
ggmap(map_z15)+
    geom_path(data=data_smooth, aes(location_long, location_lat), 
            colour = "purple", alpha = .7)+
  facet_wrap(~id)
```

*_Visual check using fence polygon._*
We know Fauna didn't leave the study site during the tracking period so this is a good way to check if filtering was successful. 

First define the fenced area.

```{r}
# Define fence polygons (zones 1 and 2)
mtr <- rbind(
  ## zone 1
  c(-37.897319, 144.429048), # S end of NW diagonal
  c(-37.894066, 144.432334), # N end of NW diagonal, i.e. NW corner
  c(-37.894749, 144.438305), # bend at main gate 
  c(-37.894693, 144.438324), # main gate
  c(-37.894803, 144.439214), # bend before N Z1/2 gate
  c(-37.894718, 144.439337), # N Z1/2 gate, i.e. NE corner 
  ## zone 2
  c(-37.892433, 144.440236), # N boundary internal aviary/Z2 i.e. NW corner
  c(-37.892803, 144.443374), # Z2 northern boundary bend 1
  c(-37.893634, 144.444076), # Z2 northern boundary bend 2
  c(-37.894585, 144.447739), # N end of Z2/Z3 boundary, i.e. NE corner
  c(-37.896515, 144.446789), # Z2/Z3 boundary bend 1
  c(-37.896726, 144.446099), # Z2/Z3 boundary bend 2
  c(-37.897964, 144.445706), # Z2/Z3 boundary bend 3
  c(-37.899960, 144.444517), # S end of Z2/Z3 boundary, i.e. SE corner
  c(-37.899908, 144.444288), # Z2/btrw NE corner
  c(-37.898280, 144.440662), # Z1/btrw pen NW corner
  ## zone 1
  c(-37.900692, 144.440368), # Z1/btrw SW corner
  c(-37.902610, 144.443002), # Z1/btrw SE corner
  c(-37.909538, 144.439648), # Z1 SE corner
  c(-37.908999, 144.434965), # Z1 southern boundary bend 1
  c(-37.907537, 144.433359), # Z1 southern boundary bend 2
  c(-37.905958, 144.430140), # Z1 southern boundary bend 3
  c(-37.905486, 144.429479), # Z1 southern boundary bend 4
  c(-37.904649, 144.427566), # Z1 SW corner
  c(-37.897319, 144.429048)  # S end of NW diagonal
  ) %>%  vect(type = "polygons", crs = "EPSG:4326") %>% t() %>%
  # add a buffer for GPS accuracy of 30m
  buffer(30)
```

Then filter for points from "Fauna" outside of the polygon. 

```{r}
# Convert df to points
points <- data_smooth %>%
  filter(id=="Fauna") %>%
  vect(geom = c("location_long", "location_lat"), crs = "EPSG:4326")

# Find points outside polygons
outside <- points[!relate(points, mtr, "intersects")] %>%
  as.data.frame(geom = "XY")
  
# Plot points outside polygon 
ggmap(map_z15)+
  geom_point(data=outside, aes(x, y), colour = "yellow", alpha = 0.7, size = 3)+
  geom_spatvector(data=mtr, inherit.aes = FALSE, colour = "white", fill = NA)+
  scale_colour_viridis_c()+
  theme_void()
```

There are only 65 points outside the fence (given a 30m buffer) which is within tolerance. Interestingly they are all clustered on the southern and eastern fenceline. 

## Apply filtering 

We apply all of the above steps to the full dataset. 

### 1) Temporal filtering

We removed points after the end of the study period (4/8/23 at the start of next experiment - translocation to Orana).

```{r}
# Import data from movebank
data_raw <- readr::read_csv(fs::dir_ls(path = "movebank")) %>%
  clean_names() %>%
  # Time in posix format
  mutate(datetime = as.POSIXct(study_local_timestamp, "%Y-%m-%d %H:%M:%S"),
         date = as.Date(datetime)) %>%
  # Remove days after end of study
  filter(date < "2023-08-04") %>%
  rename(id = individual_local_identifier)
```

### 2) Filtering by quality covariates

We used the following quality covariates:

* Altitude: set to a minimum of -10m (ground level allowing for some error) and a maximum of 60 (just above the 0.95 quartile on test data)
* HDOP: set to a maximum of 2
* Satellite count: set to a minimum of 4

```{r}
# read in FABDEM
fabdem <- rast("S38E144_FABDEM_V1-0.tif") 

# convert data to spatial points
coords <- data_raw %>%
  vect(geom = c("location_long", "location_lat"), crs = "EPSG:4326")

# Extract dem and add to dataframe
data_alt <- data_raw %>%
  mutate(terra::extract(fabdem, coords, ID = FALSE)) %>%
  rename(elevation = "S38E144_FABDEM_V1-0") %>%
  # calculate flight height
  mutate(altitude = height_above_msl - elevation)

# Apply quality covariate filters
data_qfilt <- data_alt %>%
  filter(gps_satellite_count >= 4) %>%
  filter(gps_hdop <=2) %>%
  filter(altitude < 60 & altitude >-10)

# Filtering effect
print(paste("Percentage original data removed: ", round(((nrow(data_raw)-nrow(data_qfilt)) / nrow(data_raw))*100), "%", sep = ""))
```

Percentage original data removed: 28%

### 3) Filtering biologically unrealistic movement

We defined (from test data) biologically realistic movement as speeds <2m/s (a note of caution: this shouldn't be used when the birds are undertaking long distance movements as faster speeds may be possible e.g. while gliding on wind), turning speeds of 0.5m/s, and delta speed as 0.4m/s. 

```{r}
# Append turning angle, incoming/outgoing/delta speeds to data frame per bird
birds <- unique(data_raw$id)

data_speed <- data.frame()

for(i in 1:length(birds)){
 subset <- filter(data_qfilt, id == birds[i])

 temp <- subset %>%
   mutate(speed_in  = atl_get_speed( 
           data = subset, x = "utm_easting", y = "utm_northing", time = "datetime", type = c("in")),
    speed_out = atl_get_speed(
           data = subset, x = "utm_easting", y = "utm_northing", time = "datetime", type = c("out")),
    angle = atl_turning_angle(
           data = subset, x = "utm_easting", y = "utm_northing", time = "datetime"),
    speed_delta = abs(speed_in - speed_out)
    )
 
 data_speed <- rbind(data_speed, temp)
}

# Apply turning angle and speed filtering
data_sfilt <- data_speed %>%
  filter(speed_in < 2) %>%
  filter(speed_delta < 0.4) %>%
  filter(!(speed_out >0.5 & angle <90))

# Filtering effect
print(paste("Percentage original data removed: ", round(((nrow(data_qfilt)-nrow(data_sfilt)) / nrow(data_qfilt))*100), "%", sep = ""))
```

Percentage original data removed: 7%

### 4) Median smoothing

To remove small-scale jitter. We used the smallest possible moving window (3) to retain as much real movement as possible. 

```{r}
# Apply median smooth by bird
data_smooth <- data.frame()

for(i in 1:length(birds)){
  
  subset <- filter(data_sfilt, id == birds[i])
  
  temp <- atl_median_smooth(data = subset, x = "location_lat", y = "location_long",
                                  time = "datetime", moving_window = 3)
  
  data_smooth <- rbind(data_smooth, temp)
}

# Plot smoothed data
ggmap(map_z14)+
  geom_path(data=data_smooth, aes(location_long, location_lat, colour = id), alpha = .7)+
  scale_colour_viridis_d()+
  theme_void()
```

Save data - dropping unneeded columns to save space. Originally I kept the utm easting and northing columns but I noticed a mismatch between the cleaned lat/lon and the utm, so have elected to transform the data for this calculation

```{r}
# Convert data to spatial and reproject in utm
points <- data_smooth %>%
  vect(geom = c("location_long", "location_lat"), crs = "EPSG:4326") %>%
  # re-project into zone 55S
  project("EPSG:32755") %>%
  st_as_sf()

# allocate utm coords
coords <- st_coordinates(points$geometry)

# format data frame for saving to disk
data <- data_smooth %>%
  # select columns to keep
  select(c("id", "datetime", "timestamp", "location_long", "location_lat", "acceleration_raw_x", "acceleration_raw_y", "acceleration_raw_z", "external_temperature", "altitude")) %>%
  # rename columns
  rename(longitude = location_long,
         latitude = location_lat,
         time_local = datetime,
         time_utc = timestamp) %>%
  # add utm xy columns 
  mutate(easting = st_coordinates(points$geometry)[,1],
         northing = st_coordinates(points$geometry)[,2]) %>%
  # add cohort metadata
  left_join(cohort)

# save to disk
write.csv(data, "data/data_cleaned.csv", row.names = FALSE)
```

# Survival analysis

Do reinforcers survive better than the residents? 

This is hard to answer because not tracked as long and some birds moved to Orana (right censored data). Attempt to answer this using Kaplan Meier Analysis

Start by looking at the overall survival probabilities for all birds.

```{r m6}
# Format data for Kaplan Meier Analysis - where death is TRUE i.e. 1
surv_data <- metadata %>%
  # remove columns not needed
  select(!c(location, abbbs, band, alive, release_year)) %>%
  # add survival time (persistence) - right censored data
  mutate(time = end_date - start_date) %>%
  # add status - whether death occurs
  mutate(status = ifelse(is.na(mortality), 0, 1))

km <- with(surv_data, Surv(time, status))
  
# Fit a basic survival model
kmfit <- survfit(Surv(time, status) ~ 1, data = surv_data)

# Estimated survival probabilities
summary(kmfit, times = c(1, 10, 30, 54, 100, 365))

# plot
autoplot(kmfit)
```

The probability of survival to 1 year is 53% (upper CI = 79%, lower CI = 36%). 

The probability of survival to 54 days (the study period) is 91% (upper CI = 100%, lower CI = 83%).

Now compare cohorts

```{r}
# Fit a survival model by cohort
kmfit_cohort <- survfit(Surv(time, status) ~ cohort, data = surv_data)

summary(kmfit_cohort, times = c(1,30,54))

# plot
autoplot(kmfit_cohort)

# Fit Cox Model
cox <- coxph(Surv(time, status) ~ cohort, data = surv_data)
summary(cox)
autoplot(survfit(cox))
```

The probability of survival to 54 days for residents is 87% (upper CI = 79%, lower CI = 71%). 

The probability of survival to 54 days for reinforcers is 95% (upper CI = 79%, lower CI = 86%). 

So reinforcers are slightly more likely to survive, however this effect is not significant (p=0.961). There were two disease events (one in each cohort) that accounted for most of the early deaths. Potentially the stress of translocation caused these individuals to succumb to illness. 

# Movement analysis

Read in clean data and calculate basic summary statistics. 

```{r}
# Read in cleaned data 
data <- read.csv("data/data_cleaned.csv") %>%
  # Time in posix format
  mutate(time_local = as.POSIXct(time_local, format = "%Y-%m-%d %H:%M:%OS", 
                                 tz = "Australia/Melbourne"),
         time_utc = as.POSIXct(time_utc, format = "%Y-%m-%d %H:%M:%OS", 
                                 tz = "UTC")) %>%
  # Add date
  mutate(date = as_date(time_local, tz = "Australia/Melbourne"))

# Plot cleaned data to check
ggmap(map_z14)+
  geom_path(data=data, aes(longitude, latitude, colour = id), alpha = .7)+
  scale_colour_viridis_d()+
  theme_void()

# Summary statistic: number of tracked days
length(unique(data$date))

# Summary statistic: total number of tracked days per bird
print(data %>%
  group_by(id) %>%
  summarise(length(unique(date))), n=35)

print(data %>%
  group_by(id) %>%
  summarise(days = length(unique(date))) %>%
  summarise(birddays = sum(days)))
```

Birds were tracked for a total of 284 days between October 2022 and August 2023 for a total of 3538 tracking days (sum of each bird's tracking duration). 

Wobbles and Star tracked for less than two weeks and excluded from further analyses. 

```{r}
data <- data %>%
  filter(!id %in% c("Wobbles", "Star"))
```

## Day/night

Rather than splitting data on calendar days (because they are nocturnal and movement continues over midnight) we want to split the data by diurnal and nocturnal movement. We use the sunrise/sunset time (from suncalc) to add bird date to the data. This also provides additional filtering, because jitter while the bird is stationary at its roost overinflates movement estimates, so counting only noctunal movement gives a better estimate of real movement. Additionally, we add "bird date" to the data, a 24-hour period commencing at sunset (a better indication of a "day" from the bird's perspective than calendar day), so that movements over a night (crossing midnight) can be allocated to the correct grouping. 

```{r}
# Calculate if time is pre/post dawn/dusk
suntime <- getSunlightTimes(date = unique(data$date),
                            lat = -37.90,
                            lon = 144.43,
                            keep = c("sunrise", "sunset"),
                            tz = "Australia/Melbourne") %>%
  subset(select = -c(lat, lon)) 

# Append to data frame
data_sun <- left_join(data, suntime) %>%
  mutate(tod = ifelse(time_local>sunrise & time_local<sunset, "day", "night")) %>%
  relocate(time_local, .after = tod) %>%
  na.omit()

# Plot to check - using scattermore to speed up display
ggplot(data_sun)+
  geom_scattermore(aes(easting, northing, colour = tod), alpha = 0.6)+
  coord_sf()+
  theme_void()

# Add "bird date" 
data_sun <- data_sun %>%
  # add column for how long past/to sunset
  mutate(suntime = as.numeric(difftime(time_local, sunset, units = "hours"))) %>%
  # negative sun-time values indicate it's the next day - 
  # therefore allocate previous day calendar date as "bird date"
  mutate(date_bird = as_date(ifelse(suntime > 0, date, date - 1)))

# Save day data
data_day <- data_sun %>%
  filter(tod == "day")

write.csv(data_day, "data/data_clean_day.csv", row.names = FALSE)

# Save night data
data_night <- data_sun %>%
  filter(tod == "night")

write.csv(data_night, "data/data_clean_night.csv", row.names = FALSE)
```

## Acclimation period

How long does it take birds to settle? Distance moved per night over time. Calculation is done per bird per day (bird date).

Test with one bird, "Fauna". 

```{r}
# format as amt and calculate step lengths
steps <- data_night %>%
  filter(id=="Fauna") %>%
  # format as amt track - add columns as needed
  make_track(.x = easting, .y = northing, .t = time_local, id = id, date_bird = date_bird) %>%
  steps(keep_cols = "start")

# summarise per bird date
summary <- steps %>%
  group_by(date_bird) %>%
  summarise(daily_dist = sum(sl_))

# plot histogram
hist(summary$daily_dist)

# plot over time
ggplot(summary, aes(date_bird, daily_dist))+
  geom_point()+
  geom_smooth(method = "lm")+
  theme_void()
```

Apply to all birds.

```{r}
# for loop to calculate distance moved per bird date
birds <- unique(data$id)

distance_daily <- data.frame()

for(i in 1:length(birds)){
  # Subset to bird, convert data to spatial and reproject in utm
    points <- data_night %>%
    # subset to bird
    filter(id==birds[i]) %>%
    vect(geom = c("longitude", "latitude"), crs = "EPSG:4326") %>%
    # re-project into zone 55S
    project("EPSG:32755") %>%
    st_as_sf()

  # save coords
  coords <- st_coordinates(points$geometry)

  # format as amt and calculate step lengths
  steps <- points %>%
    # get utm xy columns 
    mutate(easting = st_coordinates(points$geometry)[,1],
         northing = st_coordinates(points$geometry)[,2]) %>%
    # format as amt track 
    make_track(.x = easting, .y = northing, .t = time_local, id = id, 
               # add additional columns as needed
               date_bird = date_bird) %>%
    steps(keep_cols = "start")

  # summarise per bird date
  summary <- steps %>%
    group_by(date_bird) %>%
    summarise(daily_dist = sum(sl_)) %>%
    mutate(id = birds[i])
  
  # write out
  distance_daily <- rbind(distance_daily, summary)
  
  # alert me
  print(paste("finished calculation for ", birds[i], sep = ""))
}

# save output
write.csv(distance_daily, "data/daily_distance_moved.csv", row.names = FALSE)
```

Plot distance moved as a density plot and movement over time, per bird.

```{r}
# plot histogram
hist(distance_daily$daily_dist)

# plot density by bird
ggplot(distance_daily)+
  geom_density_ridges(aes(daily_dist, id, fill = id), alpha = 0.7)+
  scale_fill_viridis_d()+
  theme_bw()+
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank())+
  theme(legend.position = "none")+
  xlim(0,7000)+
  scale_y_discrete(expand = expansion(add = c(0, 2)))+
  xlab("Distance moved daily (m)") + 
  theme(axis.title.y=element_blank())
```

Compare cohorts average daily movement. 

```{r}
# filter to establishment period
distance_daily2 <- distance_daily %>%
  # add metadata
  left_join(select(metadata, c("id", "cohort", "start_date"))) %>%
  # calculate time since release
  mutate(elapsed = as.numeric(date_bird - start_date))
  # filter to establishment period
  filter(elapsed < 100)

# calculate cohort means
summary2 <- distance_daily2 %>%
  group_by(cohort, elapsed) %>%
  summarise(mean_daily_dist = mean(daily_dist))

# plot distance moved by cohort during establishment
ggplot(summary2)+
  geom_path(aes(elapsed, mean_daily_dist, colour = cohort))+
  theme_bw()+
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank())+
  xlab("Days post-release") + 
  ylab("Mean daily distance moved (m)")
```

Interesting. I expected to see an initial spike in movement followed by a decrease, indicating an acclimation period - like seen in previous studies of bighorn sheep. But instead we found a gradual increase over time post-release. 

Is there a difference between residents and reinforcers in their change in movement over time? 

```{r}
# limit cohort daily means to 55 days (minimum period for reinforcers)
cohort_establishment <- distance_daily2 %>%
  filter(elapsed < 56)

# plot movement
ggplot(cohort_establishment)+
  geom_smooth(aes(elapsed, daily_dist, color = cohort), method = "lm")+
  theme_minimal() +
  xlab("Days post-release") + 
  ylab("Daily distance moved (m)")

# another way to visualise (group means)
ggplot(cohort_establishment, 
       aes(elapsed, daily_dist, color = cohort, group = interaction(cohort, id))) +
  geom_line(alpha = 0.5) +
  stat_summary(fun = mean, geom = "line", aes(group = cohort), linewidth = 1.2) +
  theme_minimal() +
  xlab("Days post-release") + 
  ylab("Daily distance moved (m)")

# distribution of movement data
hist(cohort_establishment$daily_dist)

ggqqplot(cohort_establishment$daily_dist)

# correct left skew
cohort_establishment <- cohort_establishment %>%
  mutate(dist_sqrt = sqrt(daily_dist))

hist(cohort_establishment$dist_sqrt)

ggqqplot(cohort_establishment$dist_sqrt)

# test whether establishment differs between the groups
m1 <- lmer(dist_sqrt ~ cohort * elapsed + (1|id), data = cohort_establishment)
summary(m1)
anova(m1)
```

We found a significant effects of cohort, elapsed time, and the interaction of these on the daily distance moved. Residents changed their movement slightly more over time than reinforcers (estimate: 0.06766), possibly because reinforcers move more from the outset
