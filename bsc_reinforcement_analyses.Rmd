---
title: "bsc_reinforcement_analyses"
author: "Shoshana Rapley"
date: "`r Sys.Date()`"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup}
knitr::opts_chunk$set(echo = TRUE)

# Packages
pacman::p_load(adehabitatHR, amt, atlastools, beepr, cowplot, effects, emmeans, flextable, ggeffects, ggfortify, ggmap, ggnewscale, ggforce, ggpubr, ggraph, ggridges, ggspatial, glmmTMB, gtools, igraph, janitor, jtools, lme4, lmerTest, move2, momentuHMM, MuMIn, ozmaps, patchwork, performance, plotrix, readxl, scales, scattermore, sf, showtext, sjPlot, sp, suncalc, survival, survminer, terra, tidygraph, tidyterra, tidyverse, tmap, viridis, wildlifeDI)

# Google and STadia API key for ggmaps
ggmap::register_google(key = readChar("apikey_google.txt", nchars = file.info("apikey_google.txt")$size))
ggmap::register_stadiamaps(key = readChar("apikey_stadia.txt", nchars = file.info("apikey_stadia.txt")$size))

# Background maps MR zones 1 and 2
map_z13 <- get_map(c(144.4380, -37.9000), zoom=13, maptype = "satellite")
map_z14 <- get_map(c(144.4380, -37.9000), zoom=14, maptype = "satellite")
map_z15 <- get_map(c(144.4380, -37.9000), zoom=15, maptype = "satellite")
map_z16 <- get_map(c(144.4380, -37.9000), zoom=16, maptype = "satellite")

# Metadata - translocation information
metadata  <- read.csv("data/metadata.csv") %>%
  clean_names() %>%
  rename(id = identity)

# Define fence polygons (zones 1 and 2)
mtr <- rbind(
  ## zone 1
  c(-37.897319, 144.429048), # S end of NW diagonal
  c(-37.894066, 144.432334), # N end of NW diagonal, i.e. NW corner
  c(-37.894749, 144.438305), # bend at main gate 
  c(-37.894693, 144.438324), # main gate
  c(-37.894803, 144.439214), # bend before N Z1/2 gate
  c(-37.894718, 144.439337), # N Z1/2 gate, i.e. NE corner 
  ## zone 2
  c(-37.892433, 144.440236), # N boundary internal aviary/Z2 i.e. NW corner
  c(-37.892803, 144.443374), # Z2 northern boundary bend 1
  c(-37.893634, 144.444076), # Z2 northern boundary bend 2
  c(-37.894585, 144.447739), # N end of Z2/Z3 boundary, i.e. NE corner
  c(-37.896515, 144.446789), # Z2/Z3 boundary bend 1
  c(-37.896726, 144.446099), # Z2/Z3 boundary bend 2
  c(-37.897964, 144.445706), # Z2/Z3 boundary bend 3
  c(-37.899960, 144.444517), # S end of Z2/Z3 boundary, i.e. SE corner
  # hashed lines are to remove the gap of the rock wallaby pen
  #c(-37.899908, 144.444288), # Z2/btrw NE corner
  #c(-37.898280, 144.440662), # Z1/btrw pen NW corner
  ## zone 1
  #c(-37.900692, 144.440368), # Z1/btrw SW corner
  #c(-37.902610, 144.443002), # Z1/btrw SE corner
  c(-37.909538, 144.439648), # Z1 SE corner
  c(-37.908999, 144.434965), # Z1 southern boundary bend 1
  c(-37.907537, 144.433359), # Z1 southern boundary bend 2
  c(-37.905958, 144.430140), # Z1 southern boundary bend 3
  c(-37.905486, 144.429479), # Z1 southern boundary bend 4
  c(-37.904649, 144.427566), # Z1 SW corner
  c(-37.897319, 144.429048)  # S end of NW diagonal
  ) %>%  vect(type = "polygons", crs = "EPSG:4326") %>% 
  # transpose
  t()
```

# Introduction

Reinforcement is a form of conservation translocation used to stabilise or enhance populations. Reinforcement is also a stage within other forms of translocation, which usually involve multiple release cohorts and therefore have cohorts released into the presence of conspecifics. Even a reintroduction project will have conspecifics present from the second release. Benefits of reinforcing release are assumed but rarely empirically tested – and if they are its usually from perspective of reinforcing individuals, not the population as a whole. Outcomes of reinforcement are mediated by social interactions, which are also assumed but not often empirically tested. 

Here we test the outcomes of reinforcement for a population of bush stone-curlew where all individuals in the population (resident and reinforcing) are accounted for and tracked with GPS. We ask: do the cohorts integrate? Do social interactions benefit the reinforcing cohort? And, do the residents change their behaviour in response to reinforcement?

## Study site

Mt Rothwell Biodiversity Information Center (-37.8957, 144.4384, hereafter: Mt Rothwell), is a 473ha predator-exclusion fenced sanctuary and captive breeding facility in Victoria, on the traditional lands of the Wathawurrung people. Mt Rothwell is managed by the Odonata Foundation as part of a sanctuary network in southeast Australia. The sanctuary is free from the red fox, Vulpes vulpes, and feral cat, Felis catus, which are exotic predators that have contributed to the decline of Australian wildlife .

Here I make an map of the site with an Australia context inset for publication.

```{r}
# shapefile of states
aus <- ozmap("states") %>%
  vect()

lgas <- ozmap("abs_lga") %>%
  vect()

vic <- aus %>% dplyr::filter(grepl("Victoria", NAME))

# aus inset map
ausmap <- ggplot()+
  geom_sf(data = aus, fill = NA)+
  geom_sf(data = vic)+
  theme_void()+
  labs()+
  xlim(112,155)+ 
  ggplot2::theme(
    panel.border = element_rect(fill = NA, colour = "black"),
    plot.background = element_rect(fill = "white")
  )

# vic inset map
vicmap <- ggplot()+
  geom_sf(data = vic)+
  geom_rect(aes(xmin = 144.2025199, xmax = 144.7196691, 
                ymin = -38.3025956, ymax = -37.8048911), 
            colour = "darkgreen", fill = NA,
            linewidth = 1)+
  theme_void()+
  labs()+ 
  ggplot2::theme(
    panel.border = element_rect(fill = NA, colour = "black"),
    plot.background = element_rect(fill = "white")
  )

# study area stadia map
map_geelong <- get_stadiamap(c(left = 144.225, right = 144.743, 
                           bottom = -38.255, top =  -37.805),
                         zoom=11, maptype = "stamen_terrain")

geelong <- ggmap(map_geelong)+
  geom_spatvector(data = mtr, inherit.aes = FALSE, fill = NA, colour = "black",
                  linewidth = 1)+
  xlab("Longitude")+
  ylab("Latitude")+
  ggplot2::theme(plot.margin = margin(0.1,6,0.1,0.2, "cm"))+ #top, right, bottom, left
  annotation_north_arrow(location = "br", 
                         pad_x = unit(0.2, "cm"), pad_y = unit(1, "cm"),
                         height = unit(1, "cm"), width = unit(1, "cm"),
                         style = north_arrow_orienteering(text_col = "black"))+
  # add scale bar in just the resident facet panel
  annotation_scale(location = "br",
                   pad_x = unit(0.1, "cm"), pad_y = unit(0.4, "cm"),
                   text_col = "black")

geelong

# plot map and insets
ggdraw()+
  draw_plot(geelong)+
  draw_plot(ausmap, x = 0.70, y = 0.55, width = 0.3, height = 0.3)+
  draw_plot(vicmap, x = 0.716, y = 0.28, width = 0.2679, height = 0.2679)+
  draw_label("Mt Rothwell", x = 0.345, y = 0.805, size = 12)+
  draw_label("A", x = 0.06, y = 0.91, size = 20)+
  draw_label("B", x = 0.96, y = 0.82, size = 16)+
  draw_label("C", x = 0.96, y = 0.5, size = 16)
  
# save
ggsave("maps/study_site.png", dpi = 800, bg = 'white')
```

Not using but keeping here, closer map of site with You Yangs context. 

```{r}
map_mtr <- get_stadiamap(c(left = 144.375, right = 144.490, 
                           bottom = -37.975, top =  -37.865),
                         zoom=13, maptype = "stamen_terrain")

site <- ggmap(map_mtr)+
  geom_spatvector(data = mtr, inherit.aes = FALSE, fill = NA, colour = "gray10",
                  linewidth = 1.5)+
  xlab("Longitude")+
  ylab("Latitude")

```

## Translocation

We translocated 35 adult captive-bred bush stone-curlews from Mt Rothwell captive colony to Mt Rothwell Zone 1 (fenced sanctuary) in two stages. The first (pilot) cohort of 16 birds was released between October 2022 and June 2023. The second (reinforcing) cohort of 20 birds was released in June 2023. One bird in the first cohort was taken back into captivity after a single day and re-released in the second cohort; hence total 35 individuals.

## Telemetry

All translocated birds were fitted with a GPS tracker (Ornitrak20 from Ornitela) with a duty cycle of a fix every 60 seconds (or reduced when battery low). Telemetry data were stored on Movebank. We collected data from the release date of each individual until the 12th of January 2024 (when GPS devices were removed from all remaining birds except one, ahead of the 3G shutdown).

The study period for this analysis ends 5th August 2023, when half of the reinforcing cohort were translocated to a secondary site (Orana).

# Data cleaning

High throughput animal tracking data require filtering to remove erroneous points, while maintaining real movement data. We follow the workflow by [Gupte et al. (2021)](https://besjournals.onlinelibrary.wiley.com/doi/full/10.1111/1365-2656.13610), that is:

1) temporal filtering
2) filtering by quality covariates
3) filtering biologically unrealistic movement
4) median smoothing

## 1) Spatiotemporal filtering

First step of temporal filtering was done on movebank, where the start and end of deployments were specified for each individual. The start time was the time of release and the end time was when the GPS unit was removed or the last known point in the case of the deceased and missing birds.

We removed points after the end of the study period (5/8/23, at the start of next experiment - translocation to Orana).

Spatial filtering can be done to the area of interest. Only two of the birds (Marmalade and Nutmeg) left the sanctuary (other than during mortality events) so for all others we filter to the fence with a buffer of 30m. 

```{r}
# Import data from movebank and filter on time
data_raw <- readr::read_csv(fs::dir_ls(path = "movebank")) %>%
  clean_names() %>%
  # Time in posix format
  mutate(datetime = as.POSIXct(study_local_timestamp, "%Y-%m-%d %H:%M:%S"),
         date = as.Date(datetime)) %>%
  # rename id column
  rename(id = "individual_local_identifier") %>%
  # Remove days after end of study
  filter(date < "2023-08-05")

# convert data to spatial points
coords <- data_raw %>%
  vect(geom = c("location_long", "location_lat"), crs = "EPSG:4326")

# filter on location to inside fence (with 30m buffer)
data_lfilt <- terra::intersect(coords, buffer(mtr, 30)) %>%
  as.data.frame(geom = "XY") %>%
  # replace data for marmalade and nutmeg with original
  filter(!id %in% c("Marmalade", "Nutmeg")) %>%
  rename("location_long" = "x", "location_lat" = "y") %>%
  rbind(filter(data_raw, id %in% c("Marmalade", "Nutmeg")))

# Filtering effect
print(paste("Percentage original data removed: ", round(((nrow(data_raw)-nrow(data_lfilt)) / nrow(data_raw))*100), "%", sep = ""))
```

Percentage original data removed: 1% (41% with time)

## 2) Filtering by quality covariates

In the past I've found filtering by satellite count and hdop can remove errors, but when applied with the wrong parameters they can have a high rate of false positives (removing real movement) and low rate of true positives (removing unrealistic movement) so we don't want to be overly aggressive with the application of these filters.

```{r}
# Stats satellite vales
hist(data_lfilt$gps_satellite_count)
summary(data_lfilt$gps_satellite_count)
quantile(data_lfilt$gps_satellite_count, probs = 0.01, na.rm = TRUE)

# Stats hdop vales
hist(data_lfilt$gps_hdop)
hist(data_lfilt$gps_hdop, breaks = 200, xlim = c(0,3))
summary(data_lfilt$gps_hdop)
quantile(data_lfilt$gps_hdop, probs = 0.99, na.rm = TRUE)
```

Most points have a satellite count >4. 

There are a handful of massive hdop values (5-15) but the vast majority are <2 and the 99th percentile is 2.

Applying these quality covariates:

* HDOP: <2
* Satellite count: > 4

```{r}
# Apply quality covariate filters
data_qfilt <- data_lfilt %>%
  filter(gps_satellite_count > 4) %>%
  filter(gps_hdop < 2)

# Filtering effect
print(paste("Percentage original data removed: ", round(((nrow(data_lfilt)-nrow(data_qfilt)) / nrow(data_lfilt))*100), "%", sep = ""))
```

Percentage original data removed: 3%

## 3) Filtering biologically unrealistic movement

To remove spikes in the data we can filter out positions with extreme incoming and outgoing speeds. First we need to define biologically realistic incoming and outgoing speeds.

```{r}
# Append turning angle, incoming/outgoing/delta speeds to data frame per bird
birds <- unique(data_qfilt$id)

data_speed <- data.frame()

for(i in 1:length(birds)){
 subset <- filter(data_qfilt, id == birds[i])

 temp <- subset %>%
   mutate(speed_in  = atl_get_speed( 
           data = subset, x = "utm_easting", y = "utm_northing", time = "datetime", type = c("in")),
    speed_out = atl_get_speed(
           data = subset, x = "utm_easting", y = "utm_northing", time = "datetime", type = c("out")),
    angle = atl_turning_angle(
           data = subset, x = "utm_easting", y = "utm_northing", time = "datetime")
    )
 
 data_speed <- rbind(data_speed, temp)
}

# Stats incoming speeds
hist(data_speed$speed_in)
summary(data_speed$speed_in)
quantile(data_speed$speed_in, probs = 0.99, na.rm = TRUE)

# Stats outgoing speeds
hist(data_speed$speed_out)
summary(data_speed$speed_out)
quantile(data_speed$speed_out, probs = 0.99, na.rm = TRUE)

# Hist turning angle
hist(data_speed$angle)

# Filter to points with turning angle <90
turn <- filter(data_speed, angle < 90)
summary(turn$speed_out, na.rm = TRUE)
quantile(turn$speed_out, probs = 0.99, na.rm = TRUE)
```

We defined biologically realistic movement as speeds < 1.62m/s (from 99th percentile; a note of caution: this shouldn't be used when the birds are undertaking long distance movements as faster speeds may be possible e.g. while gliding on wind) and turning speeds of < 1.25. 

```{r}
# Apply turning angle and speed filtering
data_sfilt <- data_speed %>%
  filter(speed_in < 1.62) %>%
  filter(speed_out < 1.62) %>%
  filter(!(speed_out > 1.25 & angle <90)) %>%
  filter(!(speed_in > 1.25 & angle <90))

# Filtering effect
print(paste("Percentage original data removed: ", round(((nrow(data_qfilt)-nrow(data_sfilt)) / nrow(data_qfilt))*100), "%", sep = ""))
```

Percentage original data removed: 2%

## 4) Median smoothing

Even after speed/angle filtering, we retain some smaller-scale jitter. These are challenging to remove as they lie within the bounds of realistic movement. Median resampling is a method of smoothing the track to reduce jitter. We apply it sparingly, because an overly aggressive approach will cut down on real track tortuousity.  

```{r}
# Apply median smooth by bird
data_smooth <- data.frame()

for(i in 1:length(birds)){
  
  subset <- filter(data_sfilt, id == birds[i])
  
  temp <- atl_median_smooth(data = subset, x = "location_long", y = "location_lat",
                                  time = "datetime", moving_window = 3)
  
  data_smooth <- rbind(data_smooth, temp)
}
```

Plot outcome to check.

```{r}
# raw data overlaid with cleaning steps
ggplot()+
  geom_scattermore(data=data_lfilt, aes(location_long, location_lat), colour = "red")+
  geom_scattermore(data=data_qfilt, aes(location_long, location_lat), colour = "yellow")+
  geom_scattermore(data=data_sfilt, aes(location_long, location_lat), colour = "blue")+
  theme_void()

# smoothed data only
ggmap(map_z15)+
  geom_path(data=data_sfilt, aes(location_long, location_lat, colour = id), alpha = .7)+
  scale_colour_viridis_d()+
  theme_void()+
  facet_wrap(~id)

ggsave("plots/smoothed by id.jpeg", dpi = 500, width = 20, height = 20, units = "cm")
```

Looks like the precise end time for Star was not correct on movebank - seems to have the GPS unit moving back to the office after the mortality retrieval. But not an issue since this bird excluded from analyses. 

Checking the sampling rate of the smoothed data.

```{r}
steps <- data_smooth %>%
  make_track(.x = location_long, .y = location_lat, .t = datetime, id = id) %>%
  nest(data = -"id")

sampling_rates <- steps %>%
  transmute(id, summary = map(data, summarize_sampling_rate)) %>%
  unnest(summary)

sampling_rates
summary(sampling_rates$mean)
```

The mean sampling rate is 6 minutes.

Dropping unneeded columns to reduce the size of the saved file. Originally I kept the utm easting and northing columns from movebank but I noticed a mismatch between the cleaned lat/lon and the utm, so have elected to transform the data instead.

```{r}
# Convert data to spatial and reproject in utm
points <- data_smooth %>%
  vect(geom = c("location_long", "location_lat"), crs = "EPSG:4326") %>%
  # re-project into zone 55S
  project("EPSG:32755") %>%
  st_as_sf()

# allocate utm coords
coords <- st_coordinates(points$geometry)

# format data frame for saving to disk
data <- data_smooth %>%
  # select columns to keep
  dplyr::select(c("id", "datetime", "timestamp", "location_long", "location_lat", "acceleration_raw_x", "acceleration_raw_y", "acceleration_raw_z", "external_temperature")) %>%
  # rename columns
  rename(longitude = location_long,
         latitude = location_lat,
         time_local = datetime,
         time_utc = timestamp) %>%
  # add utm xy columns 
  mutate(easting = st_coordinates(points$geometry)[,1],
         northing = st_coordinates(points$geometry)[,2]) %>%
  # add cohort metadata
  left_join(dplyr::select(metadata, c("id","cohort")))

# save to disk
write.csv(data, "data/data_cleaned.csv", row.names = FALSE)
```

# Movement analysis

Here we calculate PRBM metrics from tracking data to assess the establishment of reinforcers. The reinforcement period spans the 55 days between 11 June 2023 (last reinforcer released) and the 5th August 2023 (end of study period when reinforcers are translocated to Orana).

We also compare the response of the residents pre- and post-reinforcement to see if the reinforcement changes the behaviour of the residents. The pre-reinforcement period spans the 142 days between 16th January 2023 (last resident released) to 7th June 2023 (first reinforcer released).

I run these for all the dates to make it simpler (one dataframe instead of multiple per metric for each time period) and then filter to dates as required.

```{r}
# Read in cleaned data 
data <- read.csv("data/data_cleaned.csv") %>%
  # Time in posix format
  mutate(time_local = as.POSIXct(time_local, format = "%Y-%m-%d %H:%M:%OS", 
                                 tz = "Australia/Melbourne"),
         time_utc = as.POSIXct(time_utc, format = "%Y-%m-%d %H:%M:%OS", 
                                 tz = "UTC")) %>%
  # Add date
  mutate(date = as_date(time_local, tz = "Australia/Melbourne"))
```

Calculate basic summary statistics. 

```{r}
# Summary statistic: number of tracked days
length(unique(data$date))

# Summary statistic: total number of tracked days per bird
print(data %>%
  group_by(id) %>%
  summarise(length(unique(date))), n=35)

print(data %>%
  group_by(id) %>%
  summarise(days = length(unique(date))) %>%
  summarise(birddays = sum(days)))
```

Birds were tracked for a total of 285 days between October 2022 and August 2023 for a total of 3560 tracking days (sum of each bird's tracking duration). 

Wobbles and Star tracked for less than two weeks and excluded from further analyses. 

```{r}
data <- data %>%
  filter(!id %in% c("Wobbles", "Star"))
```

## Day/night

Rather than splitting data on calendar days (because they are nocturnal and movement continues over midnight) we want to split the data by diurnal and nocturnal movement. We use the sunrise/sunset time (from suncalc) to add bird date to the data. This also provides additional filtering, because jitter while the bird is stationary at its roost overinflates movement estimates, so counting only noctunal movement gives a better estimate of real movement. Additionally, we add "bird date" to the data, a 24-hour period commencing at sunset (a better indication of a "day" from the bird's perspective than calendar day), so that movements over a night (crossing midnight) can be allocated to the correct grouping. 

```{r}
# Calculate if time is pre/post dawn/dusk
suntime <- getSunlightTimes(date = unique(data$date),
                            lat = -37.90,
                            lon = 144.43,
                            keep = c("sunrise", "sunset"),
                            tz = "Australia/Melbourne") %>%
  select(-c(lat, lon))

# Append to data frame
data_sun <- left_join(data, suntime) %>%
  mutate(tod = ifelse(time_local>sunrise & time_local<sunset, "day", "night")) %>%
  relocate(time_local, .after = tod) %>%
  na.omit()

# Plot to check - using scattermore to speed up display
ggplot(data_sun)+
  geom_scattermore(aes(easting, northing, colour = tod), alpha = 0.6)+
  coord_sf()+
  theme_void()

# Add "bird date" 
data_sun <- data_sun %>%
  # add column for how long past/to sunset
  mutate(suntime = as.numeric(difftime(time_local, sunset, units = "hours"))) %>%
  # negative sun-time values indicate it's the next day - 
  # therefore allocate previous day calendar date as "bird date"
  mutate(date_bird = as_date(ifelse(suntime > 0, date, date - 1)))

# Save day data
data_day <- data_sun %>%
  filter(tod == "day")

write.csv(data_day, "data/data_clean_day.csv", row.names = FALSE)

# Save night data
data_night <- data_sun %>%
  filter(tod == "night")

write.csv(data_night, "data/data_clean_night.csv", row.names = FALSE)
```

## Distance moved

How long does it take birds to settle? 

Distance moved per night over time. Calculation is done per bird per day (bird date).

Test with one bird, "Fauna". 

```{r}
# read in night data
data_night <- read.csv("data/data_clean_night.csv") %>%
  # format time as posixct
  mutate(time_local = as.POSIXct(time_local))

# format as amt and calculate step lengths
steps <- data_night %>%
  filter(id=="Fauna") %>%
  # format as amt track - add columns as needed
  make_track(.x = easting, .y = northing, .t = time_local, id = id, date_bird = date_bird) %>%
  steps(keep_cols = "start")

# summarise per bird date
summary <- steps %>%
  group_by(date_bird) %>%
  summarise(daily_dist = sum(sl_))

# plot histogram
hist(summary$daily_dist)

# plot over time
ggplot(summary, aes(date_bird, daily_dist))+
  geom_point()+
  geom_smooth(method = "lm")+
  theme_void()
```

Apply to all birds.

```{r}
# for loop to calculate distance moved per bird date
birds <- unique(data_night$id)

distance_daily <- data.frame()

for(i in 1:length(birds)){
  # Subset to bird, convert data to spatial and reproject in utm
    points <- data_night %>%
    # subset to bird
    filter(id==birds[i]) %>%
    vect(geom = c("longitude", "latitude"), crs = "EPSG:4326") %>%
    # re-project into zone 55S
    project("EPSG:32755") %>%
    st_as_sf()

  # save coords
  coords <- st_coordinates(points$geometry)

  # format as amt and calculate step lengths
  steps <- points %>%
    # get utm xy columns 
    mutate(easting = st_coordinates(points$geometry)[,1],
         northing = st_coordinates(points$geometry)[,2]) %>%
    # format as amt track 
    make_track(.x = easting, .y = northing, .t = time_local, id = id, 
               # add additional columns as needed
               date_bird = date_bird) %>%
    steps(keep_cols = "start")

  # summarise per bird date
  summary <- steps %>%
    group_by(date_bird) %>%
    summarise(daily_dist = sum(sl_)) %>%
    mutate(id = birds[i])
  
  # write out
  distance_daily <- rbind(distance_daily, summary)
  
  # alert me
  print(paste("finished calculation for ", birds[i], sep = ""))
}

# save output
write.csv(distance_daily, "results/daily_distance_moved.csv", row.names = FALSE)
```

Plot distance moved as a density plot and movement over time, per bird.

```{r}
# plot histogram
hist(distance_daily$daily_dist)

# plot density by bird
ggplot(distance_daily)+
  geom_density_ridges(aes(daily_dist, id, fill = id), alpha = 0.7)+
  scale_fill_viridis_d()+
  theme_bw()+
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank())+
  theme(legend.position = "none")+
  xlim(0,7000)+
  scale_y_discrete(expand = expansion(add = c(0, 2)))+
  xlab("Distance moved daily (m)") + 
  theme(axis.title.y=element_blank())

ggsave("plots/distance by id.jpeg", dpi = 500, width = 10, height = 15, units = "cm")
```

## Roost establishment

Look at the same idea as the previous section (a metric of establishment) but with diurnal roost movement rather than nightly distanced moved. 

First calculate roost locations. Test with one bird.

```{r}
# read in day data
data_day <- read.csv("data/data_clean_day.csv")

# filter to test bird
test <- data_day %>%
  filter(id == "Aurora")

# plot roosts coloured by date
ggmap(map_z15)+
  geom_density2d(data=test, aes(longitude, latitude, colour = date), inherit.aes = FALSE)+
  theme_void()+
  scale_colour_viridis_d()+
  theme(legend.position = "none")

# plot a series of dates to see if multiple roosts occur
dates <- seq(as.Date("2023-01-01"), as.Date("2023-01-12"), "days")
span <- filter(test, date %in% dates)

ggmap(map_z15)+
  geom_density2d(data=test, aes(longitude, latitude), colour = "yellow", inherit.aes = FALSE)+
  theme_void()+
  facet_wrap(~date)
```

On visual inspection, the vast majority of dates have a single roost. 

Approximate roosts positions using kmeans. Apply to all birds

```{r}
# locate kmeans center for a roost per bird per day
birds <- unique(data_day$id)
days <- unique(data_day$date)

roosts <- data.frame()

for (i in 1:length(birds)){
  for (j in 1:length(days)){
    
    #subset by bird and date
    subset <- subset(data_day, id == birds[i] & date == days[j],
                     c(easting, northing))
    # skip days where not enough points
      if (length(subset$easting)<4){next}
    
    # find kmean centers
    kmean <- kmeans(subset, centers=1)
    
    # compile data
    out <- as.data.frame(cbind(kmean$centers, npoints = kmean$size)) %>%
      mutate(id = birds[i], date = days[j])
    
    roosts <- rbind(roosts, out)
    
  }
  print(paste("Finished calculation for ", birds[i], sep = ""))
}

# characteristics of cluster data
hist(roosts$npoints)
summary(roosts$npoints)

# plot roosts by number of points
ggplot(roosts)+
  geom_point(aes(easting, northing, size = npoints, colour = id))+
  geom_path(aes(easting, northing, group = id), alpha = 0.3)+
  coord_sf()+
  scale_colour_viridis_d()+
  theme_bw()

# plot for a single bird with date as colour
ggplot(data = filter(roosts, id == "Marmalade"))+
  geom_point(aes(easting, northing, size = npoints, colour = as.Date(date)))+
  geom_path(aes(easting, northing, group = id), alpha = 0.3)+
  coord_sf()+
  scale_colour_viridis_c()+
  theme_bw()+
  theme(axis.line=element_blank(),
      axis.text.x=element_blank(),
      axis.text.y=element_blank(),
      axis.ticks=element_blank(),
      axis.title.x=element_blank(),
      axis.title.y=element_blank())

# save daily roost locations
write.csv(roosts, "results/daily_roost_location.csv", row.names = FALSE)
```

How far between consecutive roosts? 

```{r}
# read in roost locations, format as spatial
roosts <- read.csv("results/daily_roost_location.csv") %>%
  dplyr::select(!"npoints") %>%
  vect(geom = c("easting", "northing"), crs = "EPSG:32755") %>%
  st_as_sf()

# calculate distance between successive roosts per bird
birds <- unique(roosts$id)
distance_roosts <- data.frame()

for(i in 1:length(birds)){
  
  # subset to individual
  points <- filter(roosts, id==birds[i]) %>%
    # date as posix
    mutate(date = as.POSIXct(date, format = "%Y-%m-%d")) %>%
    # ensure arranged by date
    arrange(date) %>%
    #add lag column for geometry comparison
    mutate(previous = lag(geometry))
  
  # allocate the release location as the first location
  release <- st_sfc(st_point(c(274423.45, 5801912.85) ), crs = 32755) %>%
    st_as_sf()
  
  points$previous[1] <- release$x
  
  # calculate the distance between successive points
  out <- points %>%
    mutate(distance_previous = 
             as.numeric(st_distance(points$geometry, points$previous, by_element = TRUE))) %>%
    dplyr::select(!"previous")
  
  # write out
  distance_roosts <- rbind(distance_roosts, out)
}

# hist
hist(distance_roosts$distance_previous)

# transform to latlon
distance_roosts_latlon <- distance_roosts %>%
  vect() %>%
  project("EPSG:4326") %>%
  st_as_sf() %>%
  mutate(date = as_date(date))

# plot roosts with colour as distance from previous
ggplot()+
  geom_sf(data = distance_roosts_latlon, aes(colour = distance_previous))+
  scale_colour_viridis_c()+ 
  theme_void()

# plot roosts with colour as date
ggmap(map_z15)+
  geom_sf(data = distance_roosts_latlon, aes(colour = date), inherit.aes = FALSE)+
  scale_colour_viridis_c(trans = "date")+
  theme_void()
```

There is a day Nutmeg seems to have spent 3km away from their previous roost. IS that true? Investigate this outlier.

```{r}
# Read in cleaned data 
nutmeg <- read.csv("data/data_cleaned.csv") %>%
  # select only Nutmeg
  filter(id == "Nutmeg") %>%
  # Time in posix format
  mutate(time_local = as.POSIXct(time_local, format = "%Y-%m-%d %H:%M:%OS", 
                                 tz = "Australia/Melbourne"),
         time_utc = as.POSIXct(time_utc, format = "%Y-%m-%d %H:%M:%OS", 
                                 tz = "UTC")) %>%
  # Add date
  mutate(date = as_date(time_local, tz = "Australia/Melbourne")) 

# Plot
ggmap(map_z13)+
  geom_point(data=nutmeg, aes(longitude, latitude, colour = date), alpha = 0.8)+
  scale_colour_viridis_c()+
  geom_path(data=nutmeg, aes(longitude, latitude), colour = "white", alpha = 0.4)+
  theme_void()
```

Yep that looks true! On 5-11-23, Nutmeg goes on a flight to the west of the sanctuary, stays over the day near the quarry, then returns to the sanctuary the next day. 

Points outside of fence?

```{r}
# Convert df to points
points <- vect(distance_roosts_latlon)

# Find points outside polygons
outside <- points[!relate(points, mtr, "intersects")] %>%
  as.data.frame(geom = "XY")
  
# Plot points outside polygon 
ggmap(map_z15)+
  geom_point(data=outside, aes(x, y, colour = id), alpha = 0.7, size = 3)+
  geom_spatvector(data=mtr, inherit.aes = FALSE, colour = "white", fill = NA)+
  scale_colour_viridis_d()+
  theme_void()
```

One real roost outside (Nutmeg's adventure as above) and 5 where birds were just roosting close to the fence. This is fine. 

Save output.

```{r}
# convert geometry to regular columns to save to disk
distance_roosts2 <- distance_roosts_latlon %>%
  st_drop_geometry() %>%
  mutate(longitude = st_coordinates(distance_roosts_latlon$geometry)[,1],
         latitude = st_coordinates(distance_roosts_latlon$geometry)[,2])

# write to file
write.csv(distance_roosts2, "results/daily_distance_between_roosts.csv", row.names = FALSE)
```

## Release site fidelity

How far did they move from the release location? Based on daily roost distance from release location.

Calculate distance from daily roost to release location. 

Release location utm:(274423.45, 5801912.85) 
Release location lat/lon:(-37.902374, 144.434323)

```{r}
# read in roost locations, format as spatial
roosts <- read.csv("data/daily_roost_location.csv") %>%
  dplyr::select(!"npoints") %>%
  vect(geom = c("easting", "northing"), crs = "EPSG:32755") %>%
  st_as_sf()

# release coords as spatial
release  <- st_sfc(st_point(c(274423.45, 5801912.85) ), crs = 32755)

# calculate distance between roosts and release site
dist <- roosts %>%
  mutate(dist_release = as.numeric(st_distance(release, roosts))) %>%
  # keep max distance per day
  group_by(date, id) %>%
  filter(dist_release == max(dist_release)) %>%
  ungroup() %>%
  # format date as a date
  mutate(date = as_date(date)) %>%
  # arrange by date
  arrange(date) %>%
  # transform to lat lon
  vect() %>%
  project("EPSG:4326")

# plot roosts with colour as distance from release
ggmap(map_z15)+
  geom_sf(data = dist, aes(colour = dist_release), inherit.aes = FALSE)+
  scale_colour_viridis_c()+
  theme_void()

# format as data frame
dist <- st_as_sf(dist) %>%
  st_drop_geometry()

# save to file
write.csv(dist, "results/daily_roost_distance_from_release.csv", row.names = FALSE)
```

## Home range and core range

Home range change is another way to investigate post-release behavioural modification. Previous studies have demonstrated decreasing home ranges over time as individuals first explore their new surrounds and then settle on a core area of exploitation. We define home range as 90% KUD and core range as 50% KUD, with both nocturnal and diurnal fixes.

```{r}
# Read in cleaned data 
data <- read.csv("data/data_cleaned.csv") %>%
  # Time in posix format
  mutate(time_local = as.POSIXct(time_local, format = "%Y-%m-%d %H:%M:%OS", 
                                 tz = "Australia/Melbourne"),
         time_utc = as.POSIXct(time_utc, format = "%Y-%m-%d %H:%M:%OS", 
                                 tz = "UTC")) %>%
  # Add date
  mutate(date = as_date(time_local, tz = "Australia/Melbourne"))%>%
  filter(!id %in% c("Wobbles", "Star"))

# set up data in spatial points dataframe
locs <- SpatialPointsDataFrame(coordinates(
  cbind(data$easting, data$northing)), data = data)

# home range polygon per bird per day 🐢 1 hour
birds <- as.character(unique(data$id))
days <- unique(locs[["date"]])

# Create empty dataframes for both 50% and 90% KUDs
hr50_daily <- data.frame()
hr90_daily <- data.frame()

for (i in 1:length(birds)){
  for (j in 1:length(days)){
    points <- subset(locs, id == birds[i] & date == days[j],
                     select = id)
    if (length(points) < 5){
      next
    }
    
    # Calculate KUD once
    kud <- kernelUD(points[,1], h="href", grid=250, extent = 6)
    
    # Get both 50% and 90% contours from the same KUD object
    kud90 <- getverticeshr(kud, percent = 90)
    kud50 <- getverticeshr(kud, percent = 50)
    
    # Set projection for both
    proj4string(kud90) <- CRS("EPSG:32754")
    proj4string(kud50) <- CRS("EPSG:32754")
    
    # Convert to sf and add date
    kud90_df_utm <- st_as_sf(kud90) %>%
      mutate(date = days[j], 
             id = birds[i],
             hr_level = "90")
    
    kud50_df_utm <- st_as_sf(kud50) %>%
      mutate(date = days[j], 
             id = birds[i],
             hr_level = "50")
    
    # Append to respective dataframes
    hr90_daily <- rbind.data.frame(hr90_daily, kud90_df_utm)
    hr50_daily <- rbind.data.frame(hr50_daily, kud50_df_utm)
    
    # Print progress
    print(paste("Completed:", birds[i], "on", days[j]))
  }
}

# plot


# clip to fenced area (larger home ranges currently go beyond the fence linking points)
hr90_daily_clip <- hr90_daily %>%
  vect() %>%
  project("EPSG:4326") %>%
  crop(fence) %>%
  st_as_sf()

hr50_daily_clip <- hr50_daily %>%
  vect() %>%
  project("EPSG:4326") %>%
  crop(fence) %>%
  st_as_sf()

# plot

# save clipped shapefiles
st_write(hr90_daily_clip, "shapefiles/hr_90_fence_clip.shp", append = FALSE)

st_write(hr50_daily_clip, "shapefiles/hr_50_fence_clip.shp", append = FALSE)

# extract area per day i.e. drop geometry
hr_area <- st_drop_geometry(hr90_daily_clip) %>%
  rbind(st_drop_geometry(hr50_daily_clip)) %>%
  pivot_wider(names_from = hr_level, values_from = area) %>%
  rename(kud90 = "90",
         kud50 = "50")

# save to file
write.csv(hr_area, "results/daily_hr.csv", row.names = FALSE)
```

# Conspecific interactions

The key issue addressed in this paper is whether social interaction occurs between residents and reinforcers, and if so whether this mediates post-release outcomes for the cohorts. 

## Proximity analysis

First we need to determine interactions. Using GPS tracking data we cannot perfectly capture social interactions, but we can approximate these with proximity (distance and time) analysis. I elected to use the coefficient of association because it produces few few I errors, owing to its simplicity ([Long et al 2014](https://besjournals.onlinelibrary.wiley.com/doi/10.1111/1365-2656.12198)) 

To determine the temporal interaction threshold we use the mean sampling rate.

```{r}
# Read in cleaned data 
data <- read.csv("data/data_cleaned.csv") %>%
  # Time in posix format
  mutate(time_local = as.POSIXct(time_local, format = "%Y-%m-%d %H:%M:%OS", 
                                 tz = "Australia/Melbourne")) %>%
  # Add date
  mutate(date = as_date(time_local, tz = "Australia/Melbourne")) %>%
  # drop birds excluded from analyses
  filter(!id %in% c("Wobbles", "Star")) %>%
  # drop NAs
  na.omit()

# summarise sampling rate to decide on temporal interaction threshold
steps <- data %>%
  make_track(.x = easting, .y = northing, .t = time_local, id = id) %>%
  nest(data = -"id")

sampling_rates <- steps %>%
  transmute(id, summary = map(data, summarize_sampling_rate)) %>%
  unnest(summary)

mean(sampling_rates$mean)*60
mean(sampling_rates$sd)*60
```

The mean sampling rate for the cleaned data is 8 minutes. We will use a time parameter of 4 minutes (half the sampling interval) following advice from the wildlifeDI package vignette. 

First format tracks as move2 objects for use in wildlifeDI.

```{r}
# format track data as move2 object
move <- mt_as_move2(data, coords = c("easting", "northing"), time_column = "time_local", track_id_column = "id") %>%
  # add crs
  sf::st_set_crs("EPSG:32755") %>%
  # needed to omit NAs for wildlifeDI to work
  na.omit()
```

We use a dcPlot of paired encounters across distance to approximate the distance threshold (using a subset to reduce processing time).

Our practitioner guesstimate was a threshold of 30m (based on visual observation of interactions between individuals in the field during monitoring). 

```{r}
# one week subset
temp <- seq.Date(from = as_date("2023-06-01"), to = as_date("2023-06-07"), by = "day")
move_subset <- filter(move, date %in% temp)

# plot distribution of paired fixes by distance
dcPlot(move_subset,tc=4*60,dmax=500)
dcPlot(move_subset,tc=4*60,dmax=100)
```

The majority of contacts took place <40m apart. I'll retain the guesstimate of 30m as the parameter. This is also within tolerance for the approximate GPS uncertainty of approx 20m (on cleaned data).

We calculate prox for all dyads for the two time periods of interest:

  1) Residents only
  2) Residents and reinforcers
  
### Residents only

We define this as the period from the last resident released (2023-01-16) to the first reinforcer released (2023-06-07). 

```{r}
# define resident only date period
res_dates <- seq.Date(from = as_date("2023-01-16"), to = as_date("2023-06-06"), by = "day")

# subset to dates
data_resident <- move %>%
  filter(date %in% res_dates)

# Test for a single dyad
dyad <- filter(data_resident, id %in% c("Aurora", "Briar"))

checkTO(dyad)
Sys.time()
test <- Ca(dyad, tc=4*60, dc=30);Sys.time()
```

The test dyad took 47 seconds so I'm anticipating the full set of 78 interactions will take 1 hour. 

```{r}
# list of residents
residents <- unique(data_resident$id)

# All bird combinations
list <-combinations(n = 13, r = 2, v = residents, repeats.allowed = FALSE)
list1 <- list[,1]
list2 <- list[,2]

# Calculate interactions between all birds 🐢🐢
interact <- data.frame()

for(i in 1:length(list1)) {
  
  dyad <- filter(data_resident, id %in% c(list1[i], list2[i]))
  
  temp <- tryCatch({
    data.frame(Prox(dyad, tc=4*60, dc=30)) %>%
      clean_names()
  }, error = function(e) data.frame(ca = NA, bird1 = NA, bird2 = NA)) 
  
  print(paste("Finished", list1[i], "&", list2[i], i, "of 78", sep = " "))
  
  interact <- rbind(interact, temp)
}

# tidy up the output
interact2 <- interact %>%
  # remove unneeded columns
  select(id1, id2, prox) %>%
  # format prox numeric to 4 decimal places
  mutate(prox = as.numeric(format(round(prox, 4), nsmall = 4)))

# save to disk
write.csv(interact, "results/proximity_residents.csv", row.names = FALSE)

# summary statistics prox values
hist(interact2$prox)
summary(interact2$prox)
```

Mean proximity score is 13.1%, min is no interaction and max is 43.8%. 

### Residents and reinforcers

We define this as the period from the last reinforcer released (2023-06-11) to the end of the study period (when reinforcers moved to Orana 2023-08-05). Each dyad takes approx. 8 seconds so all 378 takes approx 1 hour to run. 

```{r}
# define reinforcer date period
rein_dates <- seq.Date(from = as_date("2023-06-11"), to = as_date("2023-08-05"), by = "day")

# subset to dates
data_reinforce <- move %>%
  filter(date %in% rein_dates)

# list of founders
founders <- unique(data_reinforce$id)

# All bird combinations
list <-combinations(n = 28, r = 2, v = founders, repeats.allowed = FALSE)
list1 <- list[,1]
list2 <- list[,2]

# Calculate interactions between all birds 🐢🐢
interact <- data.frame()

for(i in 1:length(list1)) {
  
  dyad <- filter(data_reinforce, id %in% c(list1[i], list2[i]))
  
  temp <- tryCatch({
    data.frame(Prox(dyad, tc=4*60, dc=30)) %>%
      clean_names()
  }, error = function(e) data.frame(ca = NA, bird1 = NA, bird2 = NA)) 
  
  print(paste("Finished", list1[i], "&", list2[i], i, "of 378", sep = " "))
  
  interact <- rbind(interact, temp)
}

# tidy up the output
interact2 <- interact %>%
  # remove unneeded columns
  select(id1, id2, prox) %>%
  # format prox numeric to 4 decimal places
  mutate(prox = as.numeric(format(round(prox, 4), nsmall = 4)))

# save to disk
write.csv(interact2, "results/proximity_reinforcers.csv", row.names = FALSE)

# summary statistics prox values
hist(interact2$prox)
summary(interact2$prox)
```

Summary stats here

## Social network

For social network analysis we use the proximity analysis of dyads completed above. Proximity networks are inferred interactions but with a highly complete data set - so we are trading off good temporal resolution and complete coverage of the population against little information on any one interaction. 

We use the package tidygraph as a wrapper for implement igraph graphics in the tidyverse API.

### Residents only

```{r}
# read in dyad proximity scores and convert to association matrix
prox1 <- read.csv("results/proximity_residents.csv") %>%
  # add rows for last and first bird self comparison
  rbind(data.frame(id1 = c("Valentine", "Aurora"),
                   id2 = c("Valentine", "Aurora"),
                   prox = c(NA, NA))) %>%
  # long to wide format
  pivot_wider(names_from = id2, values_from = prox) %>%
  # first column to rownames
  column_to_rownames("id1") %>%
  # relocate first bird to first column
  relocate(Aurora) %>%
  # format as matrix
  as.matrix()

# make symmetrical
prox1[lower.tri(prox1)] <- t(prox1)[lower.tri(prox1)]

# convert to graph object
network1 <- graph_from_adjacency_matrix(prox1, mode = "undirected", diag = FALSE, weighted = TRUE)

# network density - real edges divided by possible edges
edge_density(network1)

# network components - are all nodes connected?
components(network1)

# distance between nodes
distances(network1, algorithm="unweighted")

# proportion of node's neighbors that are connected to each other
summary(transitivity(network1, "local"))
```

We have a network of 13 individuals (nodes) and 68 edges with an edge density of 87.1%. The network is continuous (i.e. all nodes in network are connected) and the maximum degree of separation is two. 

First plot with weighted edges and nodes sized by degree centrality (number of edges - how many "friends" they have).

```{r}
# set seed to keep layout static
set.seed(4739)
layout1 <- create_layout(network1, layout = "fr") 

# plot with tidygraph (wrapper for igraph in tidy API)
ggraph(layout1)+
  # vary edge alpha by weight
  geom_edge_fan(aes(alpha = weight), show.legend = FALSE) +
  # node basic
  geom_node_point(size = 7, shape = 16)+
  # add labels
  geom_node_text(aes(label = name), nudge_y = 0.15)+
  # theme
  theme_void()
```

Next calculate community. Based on the suggestions by [Yang et al. (2016)](https://www.nature.com/articles/srep30750) Using spinglass because I have a small dense network and these perform well in that use case. 

```{r}
# community with spinglass
com <- cluster_spinglass(network1)
length(com)
modularity(com)
membership(com)

# add community to network layout
g1 <- layout1 %>%
  mutate(community = as.factor(membership(com)))
```

### Residents and reinforcers

```{r}
# read in dyad proximity scores and convert to association matrix
prox2 <- read.csv("results/proximity_reinforcers.csv") %>%
  # add rows for last and first bird self comparison
  rbind(data.frame(id1 = c("Zeus", "Athena"),
                   id2 = c("Zeus", "Athena"),
                   prox = c(NA, NA))) %>%
  # long to wide format
  pivot_wider(names_from = id2, values_from = prox) %>%
  # first column to rownames
  column_to_rownames("id1") %>%
  # relocate first bird to first column
  relocate(Athena) %>%
  # format as matrix
  as.matrix()

# make symmetrical
prox2[lower.tri(prox2)] <- t(prox2)[lower.tri(prox2)]

# convert to graph object
network2 <- graph_from_adjacency_matrix(prox2, mode = "undirected", diag = FALSE, weighted = TRUE)

# network density - real edges divided by possible edges
edge_density(network2)

# network components - are all nodes connected?
components(network2)

# distance between nodes
distances(network2, algorithm="unweighted")

# proportion of node's neighbors that are connected to each other
summary(transitivity(network2, "local"))
```

We have a network of 28 individuals (nodes) and 377 edges with an edge density of 99.7% (only one dyad doesn't have an edge, Sofi & Daisy). The network is continuous (i.e. all nodes in network are connected) and the maximum degree of separation is two. 

```{r}
# set seed to keep layout static
set.seed(1223)
layout2 <- create_layout(network2, layout = "") 

# plot with tidygraph (wrapper for igraph in tidy API)
ggraph(layout2)+
  # vary edge alpha by weight
  geom_edge_fan(aes(alpha = weight), show.legend = FALSE) +
  # node basic
  geom_node_point(size = 7, shape = 16)+
  # add labels
  geom_node_text(aes(label = name), nudge_y = 0.15)+
  # theme
  theme_void()
```

Calculate community with spinglass method.

```{r}
# community with spinglass
com <- cluster_spinglass(network2)
length(com)
modularity(com)
membership(com)

# add community to network layout
g2 <- n2 %>%
  mutate(community = as.factor(membership(com)))
```

Interesting! The reinforcers split nearly perfectly in half, with nine members in an exclusive social group (consisting only of reinforcers) and eleven members in a mixed social group (along with all the residents). Daisy was not a member of either group.

### SNA figure

```{r}
# set seed to keep layout static
set.seed(0000)

# resident network

n1 <- ggraph(comm1)+
  # community polygon
  geom_mark_hull(aes(x = x, y = y, fill = community), 
                 colour = "white", alpha = 0.2, expand = unit(0.5, "cm"),
                 show.legend = FALSE)+
  
  #scale_fill_manual(values = c("grey10", "grey60"))+
  # format edge colour, alpha and width by the weight (proximity)
  geom_edge_fan(aes(colour = weight, alpha = weight, linewidth = weight/2),
                show.legend = FALSE)+
  scale_edge_color_continuous(low = "grey", high = "slateblue4")+ 
  # node basic
  geom_node_point(size = 5, shape = 16)+
  # theme
  expand_limits(x = c(-6, 3), y = c(-4.5, 0.4))+
  theme_graph(foreground = "black", border = TRUE,
              plot_margin = margin(10, 60, 0, 60))

# reinforcer network
## network layout
networkfr2 <- create_layout(network2, layout = "fr") 

## add community and cohort to network layout
comm2 <- networkfr2 %>%
  rename(id = name) %>%
  mutate(community = as.factor(membership(w2))) %>%
  left_join(select(metadata, c(id, cohort)))

n2 <- ggraph(comm2)+
  # communities polygons
  geom_mark_hull(aes(x = x, y = y, fill = community), 
                 colour = "white", alpha = 0.2, expand = unit(0.8, "cm"),
                 show.legend = FALSE)+
  scale_fill_manual(values = c("#2E3FFF", "seagreen3"))+
  # format edge colour, alpha and width by the weight (proximity)
  geom_edge_fan(aes(colour = weight, alpha = weight, width = weight),
                show.legend = FALSE)+
  scale_edge_color_continuous(low = "grey90", high = "slateblue4")+ 
  scale_edge_width(range = c(0.1, 3))+
  # node shape by cohort
  geom_node_point(aes(shape = cohort), size = 5, 
                  show.legend = TRUE)+
  scale_shape_manual(values=c(15, 16))+
  # theme
  expand_limits(x = c(2, 7), y = c(-3.8, 2.6))+
  theme_graph(foreground = "black", border = TRUE,
              plot_margin = margin(10, 20, 5, 20))+  #top, right, bottom, left
  # legend control
  guides(fill = "none", edge_colour = "none", edge_width = "none", edge_alpha = "none")

n2

# multi panel
ggarrange(n1, n2, 
          labels = c("A", "B"),
          ncol = 1, nrow = 2,
          common.legend = TRUE, 
          legend="bottom",
          heights = c(0.6, 1))

# save
ggsave("plots/social_network_both.png", dpi = 700, width = 16, height = 19, units = "cm")
```


# Statistical analysis: reinforcers

Instead of using dyad connections, we can use the social groups (which are serendipitously nearly evenly split among the reinforcers) to ask questions about conspecific interactions. Social groups can tell you more about the overall social environment than dyads alone (Farine and Whitehal 2015).

We hypothesised members of the mixed resident-reinforcer social group would proceed more quickly through the PRBM phases than those in the reinforcer only group. I also want to compare both reinforcer groups to the residents to see if one is more similar than the other.

Dates are from the last reinforcer released to the first reinforcer translocated to the secondary site. 

```{r}
# social group membership
club <- c("Rowan", "Rory", "Fauna", "Zeus", "Rocky", "Sofi", "Loki", "Avery", "Maeve")

# define reinforcer date period
rein_dates <- seq.Date(from = as_date("2023-06-11"), to = as_date("2023-08-05"), by = "day")
```

### m1: Distance moved

Does daily distance moved differ between the social groups?

```{r}
# read in data and filter to reinforcement period
datam1 <- read.csv("results/daily_distance_moved.csv") %>%
  # add metadata
  left_join(dplyr::select(metadata, c("id", "cohort"))) %>%
  # format dates as dates
  mutate(date = as_date(date_bird)) %>%
  # limit to reinforcement period
  filter(date %in% rein_dates) %>%
  # add a time elapsed post-release variable
  mutate(elapsed = as.numeric(date - as_date("2023-06-10"))) %>%
  # add column for membership to social group
  mutate(social = ifelse(id %in% club, "Reinforcer - exclusive", ifelse(cohort == "Resident", "Resident", "Reinforcer - mixed"))) %>%
  # convert group to factor and set resident as the intercept
  mutate(social = factor(social, levels = c("Resident", "Reinforcer - mixed", "Reinforcer - exclusive")))

# create social group means
sum1 <- datam1 %>%
  group_by(date, social) %>%
  summarise(dist = mean(daily_dist),
            upper = dist + 1.96 * std.error(daily_dist),
            lower = dist - 1.96 * std.error(daily_dist)) %>%
  arrange(date)

# plot daily distance over time as social group means
ggplot(sum1, aes(date, dist, ymin = lower, ymax = upper)) +
  geom_path(aes(colour = social)) +
  geom_ribbon(aes(fill = social), alpha = 0.2) +
  xlab("Days post-reinforcement") + 
  ylab("Daily distance moved (m)") +
  theme_minimal() +
  scale_fill_viridis_d()+
  scale_colour_viridis_d()

# distribution of movement data
hist(datam1$daily_dist)
ggqqplot(datam1$daily_dist)

# test difference between the groups with interaction of time as a quadratic
m1 <- glmmTMB(daily_dist ~ social * (scale(elapsed) + I(scale(elapsed)^2)) + (1|id), 
              data = datam1,
              na.action = "na.fail")

# model selection
dm1 <- dredge(m1)

dm1

# parsimonious model where delta <2 and fewest predictors 
# in this case only one model (the top ranked) delta AICc < 2
best1 <- get.models(dm1, delta == 0)[[1]] 

# check model
check_model(best1)

# summary
summary(best1)

# post-hoc comparison of slopes
emtrends(best1, pairwise ~ social, var = "elapsed")

# plot effects
plot_model(best1)

# marginal effects 
pred1 <- predict_response(best1, terms = c("elapsed [all]", "social"))

# plot predictions
ggplot(pred1, aes(x, predicted, fill = group, ymin = conf.low, ymax = conf.high)) +
  geom_line(aes(colour = group))+
  geom_ribbon(alpha = 0.2)+
  xlab("Days post-reinforcement") + 
  ylab("Predicted values of daily distance moved (m)") +
  theme_minimal()+
  scale_fill_viridis_d()+
  scale_colour_viridis_d()
```

**Results:**
The best fitting model included social group and time (linear and quadratic), the interaction between these, and individual as a random effect.

Distance moved per day increased with time post-release (estimate: 277.75 ± 41.19 SE, p < 0.001). Both reinforcer groups had significant negative quadratic responses over time compared to residents, meaning the increase of distance over time decelerated. 

The exclusive reinforcer group had a significantly lower slope of movement increase over time compared to the residents (p = 0.0143) and weakly lower compared to the mixed reinforcers (p=0.0459). 

**Interpretation:**
Reinforcers increase over time in response to the need to explore (find resources etc.) then stabilising - evidence of establishment. 

Also increase in movement may align with theoretical increase in fitness and physical capability with increased time out of captivity.

Movement by the residents might be influenced by factors unrelated to settlement. 

### m2: Roost fidelity

Does distance between roosts differ between the social groups?

```{r}
# read in data and filter to reinforcement period
datam2 <- read.csv("results/daily_distance_between_roosts.csv") %>%
  # add metadata
  left_join(dplyr::select(metadata, c("id", "cohort"))) %>%
  # format dates as dates
  mutate(date = as_date(date)) %>%
  # limit to reinforcement period
  filter(date %in% rein_dates) %>%
  # add a time elapsed post-release variable and scale it
  mutate(elapsed = as.numeric(date - as_date("2023-06-10"))) %>%
  # add column for membership to social group
  mutate(social = ifelse(id %in% club, "Reinforcer - exclusive", ifelse(cohort == "Resident", "Resident", "Reinforcer - mixed"))) %>%
  # convert group to factor and set resident as the intercept
  mutate(social = factor(social, levels = c("Resident", "Reinforcer - mixed", "Reinforcer - exclusive")))

# create social group means
sum2 <- datam2 %>%
  group_by(date, social) %>%
  summarise(dist = mean(distance_previous),
            upper = dist + 1.96 * std.error(distance_previous),
            lower = dist - 1.96 * std.error(distance_previous)) %>%
  arrange(date)

# plot roost displacement over time as social group means
ggplot(sum2, aes(date, dist, ymin = lower, ymax = upper)) +
  geom_path(aes(colour = social)) +
  geom_ribbon(aes(fill = social), alpha = 0.2) +
  xlab("Days post-reinforcement") + 
  ylab("Distance between consecutive roosts (m)") +
  theme_minimal() +
  scale_fill_viridis_d()+
  scale_colour_viridis_d()

# distribution of movement data
hist(datam2$distance_previous)
ggqqplot(datam2$distance_previous)

# correct left skew
hist(log1p(datam2$distance_previous))
ggqqplot(log1p(datam2$distance_previous))

# test difference between the groups with interaction of time as a quadratic
m2 <- glmmTMB(log1p(distance_previous) ~ social * (scale(elapsed) + I(scale(elapsed)^2)) + (1|id), 
              data = datam2,
              na.action = "na.fail")

# model selection
dm2 <- dredge(m2)

dm2

# parsimonious model where delta <2 and fewest predictors 
#  in this case only one model (the top ranked) delta AICc < 2
best2 <- get.models(dm2, delta == 0)[[1]]

# check model
check_model(best2)

# summary
summary(best2)

# plot effects
plot_model(best2)

# marginal effects 
pred2 <- predict_response(best2, terms = c("elapsed [all]", "social"))

# plot predictions
ggplot(pred2, aes(x, predicted, fill = group, ymin = conf.low, ymax = conf.high)) +
  geom_line(aes(colour = group))+
  geom_ribbon(alpha = 0.2)+
  xlab("Days post-reinforcement") + 
  ylab("Predicted values of roost displacement (m)") +
  theme_minimal()+
  scale_fill_viridis_d()+
  scale_colour_viridis_d()
```

**Results:**
The best fitting model included social group, time (linear and quadratic), the interaction between these (only quadratic) and individual as a random effect. 

Roost displacement generally decreased over time (estimate: -0.101 ± 0.032, p = 0.0014). However, this effect was mediated by social group, where exclusive reinforcers moved significantly further than residents (estimate: 0.71 ± 0.13, p < 0.001) and had a significant quadratic interaction (estimate: -0.21496 ± 0.09176, p = 0.01915) such that they initially increased before reaching a peak and declining. 

The mixed reinforcers were not significantly different from residents. 

**Interpretation:**
Distance between consecutive roosts is a metric for home range establishment in space. Shorter distances between consecutive roosts indicate an individual is staying within a patch and building up familiarity in the roost locations; whereas large distances between consecutive roosts indicate continued searching or lack of stability.

Group co-membership with residents improved roost establishment and fidelity. This could be due to signalling good habitat, thereby reducing the need to explore additional roost sites, or due to social bonds. 

Whereas the exclusive group showed a more "conventional" trend, of initial increase (with exploration) before declining (exploitation).

### m3: Release site fidelity

Does distance from the release site differ between the social groups?

```{r}
# read in data and filter to reinforcement period
datam3 <- read.csv("results/daily_roost_distance_from_release.csv") %>%
  # add metadata
  left_join(dplyr::select(metadata, c("id", "cohort"))) %>%
  # format dates as dates
  mutate(date = as_date(date)) %>%
  # limit to reinforcement period
  filter(date %in% rein_dates) %>%
  # add a time elapsed post-release variable
  mutate(elapsed = as.numeric(date - as_date("2023-06-10"))) %>%
  # add column for membership to social group
  mutate(social = ifelse(id %in% club, "Reinforcer - exclusive", ifelse(cohort == "Resident", "Resident", "Reinforcer - mixed"))) %>%
  # convert group to factor and set resident as the intercept
  mutate(social = factor(social, levels = c("Resident", "Reinforcer - mixed", "Reinforcer - exclusive")))

# create social group means
sum3 <- datam3 %>%
  group_by(date, social) %>%
  summarise(dist = mean(dist_release),
            upper = dist + 1.96 * std.error(dist_release),
            lower = dist - 1.96 * std.error(dist_release)) %>%
  arrange(date)

# plot distance from release site over time as social group means
ggplot(sum3, aes(date, dist, ymin = lower, ymax = upper)) +
  geom_path(aes(colour = social)) +
  geom_ribbon(aes(fill = social), alpha = 0.2) +
  xlab("Days post-reinforcement") + 
  ylab("Distance from release site (m)") +
  theme_minimal() +
  scale_fill_viridis_d()+
  scale_colour_viridis_d()

# distribution of movement data
hist(datam3$dist_release)
ggqqplot(datam3$dist_release)

# correct left skew - still not great but a bit better
hist(sqrt(datam3$dist_release))
ggqqplot(sqrt(datam3$dist_release))

# test difference between the groups with interaction of time as a quadratic
m3 <- glmmTMB(sqrt(dist_release) ~ social * (scale(elapsed) + I(scale(elapsed)^2)) + (1|id), 
              data = datam3,
              na.action = "na.fail")

# model selection
dm3 <- dredge(m3)
dm3

# parsimonious model where delta <2 and fewest predictors 
# in this case there was only one model (the top ranked) with delta <2
best3 <- get.models(dm3, delta ==0)[[1]]

# check model
check_model(best3)

# summary
summary(best3)

# post-hoc comparison of means
emmeans(best3, pairwise ~ social, type = "response")

# post-hoc comparison of slopes
emtrends(best3, pairwise ~ social, var = "elapsed")

# plot effects
plot_model(best3)

# marginal effects 
pred3 <- predict_response(best3, terms = c("elapsed [all]", "social"))

# plot predictions
ggplot(pred3, aes(x, predicted, fill = group, ymin = conf.low, ymax = conf.high)) +
  geom_line(aes(colour = group))+
  geom_ribbon(alpha = 0.2)+
  xlab("Days post-reinforcement") + 
  ylab("Predicted values of distance from release site (m)") +
  theme_minimal()+
  scale_fill_viridis_d()+
  scale_colour_viridis_d()
```

**Results:**
The best fitting model included social group and time (linear and quadratic), the interaction between these, and individual as a random effect.

Distance from the release site significantly increased over time (estimate: 0.6600 ± 0.1704, p = 0.0001) and had a positive quadratic effect, indicating an acceleration of this increase (estimate: 1.2086 ± 0.1883, p < 0.0001). Mixed reinforcers did not differ from residents in the rate of increase. 

Exclusive reinforcers moved significantly further from the release site than both mixed reinforcers and residents (p < 0.0001). Exclusive reinforcers exhibit a marked deceleration compared to the other groups.

**Interpretation:**
Mixed reinforcers had greater release site fidelity than exclusive reinforcers. Tactically, site fidelity is importancde because, first, hyperdispersal increases chance of predation, and second, the release area has suitable resources for long-term survival and recruitment. 

An alternative explanation is that the exclusive birds were pushed away e.g. due to territoriality or population capacity- but I don't think this is the case because they continued to have interactions with the other group including some time roosting in the central woodland.

Deceleration in distance by the exclusive reinforcers was probably because they reached the edge of fenced reserve so couldn't move further away from the release site. 

#### Release site fidelity map

How do they move away from the release site over time

```{r}
ggmap(map_z15)+
  # plot roosts colour by time
  geom_point(aes(longitude, latitude, colour = date),
             size = 2, data = datam2, inherit.aes = FALSE)+
  # add release location
  geom_point(aes(144.434323, -37.902374), 
             colour = "white", size = 5, shape = 13, inherit.aes = FALSE)+
  # add fence
  geom_spatvector(data = mtr, inherit.aes = FALSE, fill = NA, colour = "white",
                  linetype = "longdash")+
  # wrap by period
  facet_wrap(~social)+
  # theme options
  scale_colour_viridis_c(trans = "date", name = "2023")+
  theme_void()+
  scale_y_continuous(expand = expansion(mult = c(0, 0.01)))+
  #theme(legend.position="bottom",
        #legend.key.width = unit(3, 'cm'),
        #strip.text = element_text(size = 13))+
  # add north in just the resident facet panel
  annotation_north_arrow(data  = subset(datam2, social == "Reinforcer - exclusive"),
                         location = "tr", 
                         height = unit(0.8, "cm"), width = unit(0.7, "cm"),
                         style = north_arrow_orienteering(text_col = "black"))+
  # add scale bar in just the resident facet panel
  annotation_scale(data  = subset(datam2, social == "Reinforcer - exclusive"),
                   location = "br", text_col = "black",
                   pad_x = unit(0.1, "cm"), pad_y = unit(0.4, "cm"))+
  # legend and label format
  ggplot2::theme(legend.position = "bottom",
                 legend.key.width = unit(3,"cm"),
                 strip.text = element_text(size = 11))

# save
ggsave("maps/roost_location_social_groups.png", dpi = 800, bg = 'white')
```

### m4: Home range size

Does home range size differ between the social groups? Using 90% KUD because interested in full range of exploration/exploitation under PRBM. 

```{r}
# read in data and filter to reinforcement period
datam4 <- read.csv("results/daily_hr90_area.csv") %>%
  # add metadata
  left_join(dplyr::select(metadata, c("id", "cohort"))) %>%
  # format dates as dates
  mutate(date = as_date(date)) %>%
  # limit to reinforcement period
  filter(date %in% rein_dates) %>%
  # add a time elapsed post-release variable
  mutate(elapsed = as.numeric(date - as_date("2023-06-10"))) %>%
  # add column for membership to social group
  mutate(social = ifelse(id %in% club, "Reinforcer - exclusive", ifelse(cohort == "Resident", "Resident", "Reinforcer - mixed"))) %>%
  # convert group to factor and set resident as the intercept
  mutate(social = factor(social, levels = c("Resident", "Reinforcer - mixed", "Reinforcer - exclusive")))

# create social group means
sum4 <- datam4 %>%
  group_by(date, social) %>%
  summarise(dist = mean(area),
            upper = dist + 1.96 * std.error(area),
            lower = dist - 1.96 * std.error(area)) %>%
  arrange(date)

# and overall means
mean4 <- datam4 %>%
  group_by(social) %>%
  summarise(mean = mean(area),
            se = std.error(area))

# plot homer range size over time as social group means
ggplot(sum4, aes(date, dist, ymin = lower, ymax = upper)) +
  geom_path(aes(colour = social)) +
  geom_ribbon(aes(fill = social), alpha = 0.2) +
  xlab("Days post-reinforcement") + 
  ylab("Home range 90% KUD (ha)") +
  theme_minimal() +
  scale_fill_viridis_d()+
  scale_colour_viridis_d()

# distribution of movement data
hist(datam4$area)
ggqqplot(datam4$area)

# correct left skew
hist(log1p(datam4$area))
ggqqplot(log1p(datam4$area))

# test difference between the groups with interaction of time as a quadratic
m4 <- glmmTMB(log1p(area) ~ social * (scale(elapsed) + I(scale(elapsed)^2))+ (1|id), 
              data = datam4,
              na.action = "na.fail")

# model selection
dm4 <- dredge(m4)
dm4

# parsimonious model where delta <2 and fewest predictors 
# in this case there was only one model (the top ranked) with delta <2
best4 <- get.models(dm4, delta==0)[[1]]

# check model
check_model(best4)

# summary
summary(best4)

# post-hoc comparison of means
emmeans(best4, pairwise ~ social, type = "response")

# post-hoc comparison of slopes
emtrends(best4, pairwise ~ social, var = "elapsed")

# plot effects
plot_model(best4)

# marginal effects 
pred4 <- predict_response(best4, terms = c("elapsed [all]", "social"))

# plot predictions
ggplot(pred4, aes(x, predicted, fill = group, ymin = conf.low, ymax = conf.high)) +
  geom_line(aes(colour = group))+
  geom_ribbon(alpha = 0.2)+
  xlab("Days post-reinforcement") + 
  ylab("Predicted values of home range area (ha)") +
  theme_minimal()+
  scale_fill_viridis_d()+
  scale_colour_viridis_d()
```

**Results:**
The best fitting model included social group and time (linear and quadratic), the interaction between these, and individual as a random effect.

No linear effect (i.e. no increase over time). However, the quadratic term is significant and negative (estimate: -0.19704 ± 0.04181, p < 0.001) i.e., an initial increase followed by a decrease, although the trend over time varies across social groups. The mixed reinforcers show a quadratic effect (-0.1248, p = 0.0213) and the exclusive reinforcers show a stronger quadratic effect (-0.2026, p < 0.001) compared to residents. Exclusive reinforcers decrease home range size significantly more than both other groups (p < 0.0002).

All groups have significantly different home range size. 

**Interpretation:**
Stabilising home range area (significant negative quadratic term) indicates progression along establishment occurs for both groups - this is similar to roost site fidelity, showing exploration then contraction. 

Exclusive reinforcers have the smallest home ranges, perhaps related to distance moved - they decline their home range size significantly more than mixed reinforcers. Mixed reinforcers may be benefiting from habitat cues, prompting them to explore more, or from perceived safety being in the larger group.

### m5: Weight change

In addition to the movement-based metrics of performance I wanted to look at health check data. Weight change post-release is a good indicator of performance, where some loss is expected but less steep decline (trending towards stability) indicates better performance.

We were unable to compare residents to reinforcers for weight change because we did not have weight measurements for the six individuals released in January 2023 (backpacks fitted in the December trip and released by Mt Rothwell staff rather than me going back down there). So we can only compare reinforcers, but interested to see how the social group memberships contrast.

Unlike the movement data, the study period is for 70 days because weights were taken after the 55 minimum common tracking period. 

```{r}
# read in data and clean up
datam5 <- read_xlsx("data/healthchecks.xlsx") %>%
  clean_names() %>%
  rename(id = identity) %>%
  select(id, date, weight) %>%
  # add metadata
  left_join(select(metadata, c(id, start_date, cohort))) %>%
  drop_na() %>%
  # format dates
  mutate(date = as_date(date),
         start_date = as_date(start_date)) %>%
  # calculate elapsed time and add status
  mutate(elapsed = as.numeric(date - start_date)) %>%
  # keep only reinforcers
  filter(cohort == "Reinforcing") %>%
  # add social group membership %>%
   mutate(social = as_factor(ifelse(id %in% club, "Reinforcer - exclusive", ifelse(cohort == "Resident", "Resident", "Reinforcer - mixed")))) %>%
  # keep only the latest pre-release values and assign to pre/post release
  group_by(id) %>%
  filter(elapsed > 0 | elapsed == max(elapsed[elapsed <= 0])) %>%
  ungroup() %>%
  mutate(status = as_factor(ifelse(elapsed > 0, "post-release", "pre-release"))) %>%
  arrange(id) %>%
  # filter to study period
  filter(elapsed <70)

# plot weight pre and post-release
ggplot(datam5)+
  geom_boxplot(aes(social, weight))+
  theme_minimal()+
  facet_wrap(~status)
```

We have pre and post data for 18 of the 20 reinforcers. All lost weight. The mixed social group started out on average lower than the exclusive group.

Next I calculated the change in weight both in grams and as a proportion of starting weight (to account for variation in body sizes).

```{r}
# calculate weight change in grams and as a proportion of starting weight
sum5 <- datam5 %>%
  select(c(id, social, weight, status)) %>%
  pivot_wider(names_from = status, values_from = weight) %>%
  clean_names() %>%
  drop_na() %>%
  # add change columns
  mutate(diff = pre_release - post_release,
         proportion = diff/pre_release) %>%
  # format social group as factor
  mutate(social = as_factor(social))

# plot total weight differences by social group
ggplot(sum5)+
  geom_boxplot(aes(social, diff))+
  theme_minimal()

# plot proportional weight differences by social group
ggplot(sum5)+
  geom_boxplot(aes(social, proportion))+
  theme_minimal()
```

Although total weight change seems on average lower in the mixed group, proportionally it does not look like a lot of difference.

```{r}
# check distribution of the difference
hist(sum5$diff)
ggqqplot(sum5$diff)

# test whether weight change differs between the social groups
# as total difference
m5a <- glmmTMB(diff ~ social, data = sum5)
summary(m5a)
# and as a proportion of starting weight
m5b <- glmmTMB(proportion ~ social, data = sum5)
summary(m5b)

# predictions
pred5b <- predict_response(m5b, terms = c("social"))

# plot predictions
ggplot(pred5b, aes(x, predicted, colour = x))+
  geom_pointrange(aes(ymin = conf.low, ymax = conf.high))+
  xlab("Social group membership") + 
  ylab("Predicted values of proportion starting weight lost")+
  theme_classic()+
  scale_y_continuous(limits = c(0, 0.3))
```

There is no significant differences between groups for weight loss.

I want to model predicted effects of overall weight change so I can model a geom_line of pre and post translocation (I think the geom_pointrange looks boring).

```{r}
# weight change over time between social groups
m5 <- glmmTMB(weight ~ social * status, data = datam5)
summary(m5)

# predictions
pred5 <- predict_response(m5, terms = c("status", "social"))

# plot predictions
ggplot(pred5, aes(x, predicted, fill = group, ymin = conf.low, ymax = conf.high, group = group)) +
  geom_line(aes(colour = group))+
  geom_ribbon(alpha = 0.2)+
  xlab(element_blank())+ 
  ylab("Predicted weight (g)") +
  theme_minimal()
```

Significant effect of status (pre and post release) No difference between groups.

## Figure: reinforcer stats

Multi-plot of predicted values for all PRBM metrics by social group over time.

```{r}
# set default theme options for all plots
pal <- c("#AFACAC","#2E3EDC", "#07A567")

theme <- function(){
  list(
    geom_line(aes(colour = group)),
    geom_ribbon(alpha = 0.2),
    xlab("Days post-reinforcement"),
    scale_x_continuous(breaks=seq(0, 50, 10)),
    theme_classic(),
    ggplot2::theme(axis.title.y = element_text(hjust = 0.5, size = 10),
                   axis.title.x = element_text(size = 10)),
    scale_color_manual(values = pal,
                       name = "Cohort and social group membership",
                       guide="none"),
    scale_fill_manual(values = pal,,
                      name = "Cohort and social group membership",
                      guide="none")
  )
}

# list of plots
g1 <- ggplot(pred1, aes(x, predicted, fill = group, ymin = conf.low, ymax = conf.high)) +
  ylab("Daily distance moved (m)")+
  theme()

g2 <- ggplot(pred2, aes(x, predicted, fill = group, ymin = conf.low, ymax = conf.high)) +
  ylab("Roost displacement (m)")+
  theme()

g3 <- ggplot(pred3, aes(x, predicted, fill = group, ymin = conf.low, ymax = conf.high)) +
  ylab("Distance from release (m)")+
  theme()

g4 <- ggplot(pred4, aes(x, predicted, fill = group, ymin = conf.low, ymax = conf.high)) +
  ylab("Home range area (ha)")+
  theme()

g5 <- ggplot(pred5, aes(x, predicted, fill = group, 
                        ymin = conf.low, ymax = conf.high, group = group)) +
  geom_line(aes(colour = group))+
  geom_ribbon(alpha = 0.2)+
  theme_classic()+
  xlab("Time period")+
  ylab("Weight (g)") +
  scale_colour_manual(values = c("#2E3EDC", "#07A567"), guide="none")+
  scale_fill_manual(values = c("#2E3EDC", "#07A567"), guide="none")+
  ggplot2::theme(axis.title.y = element_text(hjust = 0.5, size = 10),
                 axis.title.x = element_text(size = 10))

# make legend
temp <- ggplot(pred1, aes(x, predicted, fill = group, ymin = conf.low, ymax = conf.high)) +
  geom_line(aes(colour = group)) +
  geom_ribbon(alpha = 0.2) +
  scale_color_manual(values = pal,
                       name = "Cohort and social group\nmembership")+
  scale_fill_manual(values = pal,
                      name = "Cohort and social group\nmembership")+
  ggplot2::theme(legend.title=element_text(size=10.5))
legend <- get_legend(temp)

# multi plot 3x2
combined_plot <- (g1 + g2 + g3)  / (g4 + g5 + legend) + 
  plot_annotation(tag_levels = 'A')
combined_plot

# save 
ggsave("plots/reinforcer_outcomes.png", dpi = 400)
```

## Table: reinforcer models

Create model select and model effects tables for publication supp materials.

```{r}
# best models
tab_model(best1, best2, best3, best4, m5, show.est = TRUE, show.se = TRUE, show.ci = FALSE,
          file = "results/m1-5_effects.xls")

# model selection table
ms <- mutate(as.data.frame(dm1), model = "distance daily") %>%
  rbind(mutate(as.data.frame(dm2), model = "roost displacement")) %>%
  rbind(mutate(as.data.frame(dm3), model = "release fidelity")) %>% 
  rbind(mutate(as.data.frame(dm4), model = "home range"))

write.csv(ms, "results/m1-4_modelselection.csv", row.names = FALSE)
```

# Statistical analysis residents

We want to know if the residents change their behaviour in response to the reinforcing release. To test this we compare their movement metrics before and after the reinforcement for the same period i.e. 60 days either side. Unlike the reinforcer dates, we are measuring post-release from the *first* reinforcer released, rather than the last - because these 3 days still have potential to impact the residents. 

```{r}
# define pre-release date period
pre_dates <- seq.Date(from = as_date("2023-04-08"), to = as_date("2023-06-06"), by = "day")

# define post-release date period
post_dates <- seq.Date(from = as_date("2023-06-07"), to = as_date("2023-08-05"), by = "day")

# all dates
dates <- c(pre_dates, post_dates)
```

## m6: Distance moved

Do residents change their distance moved after reinforcement?

```{r}
# read in data and filter to residents for reinforcement period
datam6 <- read.csv("results/daily_distance_moved.csv") %>%
  # add metadata
  left_join(dplyr::select(metadata, c("id", "cohort"))) %>%
  # select only residents
  filter(cohort == "Resident") %>%
  # format dates as numeric
  mutate(date = as_date(date_bird)) %>%
  # limit to reinforcement period
  filter(date %in% dates) %>%
  # add column for pre or post release
  mutate(period = factor(ifelse(date %in% pre_dates, 
                         "pre-reinforcement", "post-reinforcement"),
                         levels  = c("pre-reinforcement", "post-reinforcement")))

# create social group means
sum6 <- datam6 %>%
  group_by(date) %>%
  summarise(dist = mean(daily_dist),
            upper = dist + 1.96 * std.error(daily_dist),
            lower = dist - 1.96 * std.error(daily_dist)) %>%
  arrange(date)

# plot daily distance over time as period means
ggplot(sum6, aes(date, dist, ymin = lower, ymax = upper)) +
  geom_path() +
  geom_ribbon(alpha = 0.2) +
  xlab("Days post-reinforcement") + 
  ylab("Daily distance moved (m)") +
  theme_minimal() +
  scale_fill_viridis_d()+
  scale_colour_viridis_d()+
  geom_vline(aes(xintercept = as_date("2023-06-07")), colour = "purple")

# distribution of movement data
hist(datam6$daily_dist)
ggqqplot(datam6$daily_dist)

# test difference pre and post reinforcement
m6 <- glmmTMB(daily_dist ~ period * (scale(as.numeric(date)) + I(scale(as.numeric(date))^2)) + (1|id), 
              data = datam6,
              na.action = "na.fail")

# model selection
dm6 <- dredge(m6)
dm6

# parsimonious model where delta <2 and fewest predictors 
# in this case only one model (top ranked) had delta AICc <2
best6 <- get.models(dm6, delta<2)[[1]]

# check model
check_model(best6)

# summary
summary(best6)

# plot effects
plot_model(best6)
```

**Plot**

Unlike the reinforcer data, we are comparing the residents pre- and post-reinforcement. So the predictions need to be bounded into valid date range. 

```{r}
# Generate prediction data only within valid date ranges
release_date <- as_date("2023-06-07")

pred_data_pre <- expand.grid(
  date = seq(min(datam6$date[datam6$period == "pre-reinforcement"]),
             release_date - 1, by = 1),
  period = "pre-reinforcement"
)

pred_data_post <- expand.grid(
  date = seq(release_date, max(datam6$date[datam6$period == "post-reinforcement"]), by = 1),
  period = "post-reinforcement"
)

# Combine and add necessary covariates (date2, id, etc.)
pred6 <- rbind(pred_data_pre, pred_data_post) %>%
  mutate(id = NA)

# Predict values using the valid dataset
values6 <- predict(best6, newdata = pred6, type = "response", se.fit = TRUE) %>%
  as.data.frame() 

# Add predictions to dataframe
pred6 <- pred6 %>%
  mutate(predicted = values6$fit,
         lower = values6$fit - 1.96 * values6$se.fit,
         upper = values6$fit + 1.96 * values6$se.fit) %>%
  # convert date back to date
  mutate(date = as_date(date))

# plot predictions
ggplot(pred6, aes(date, predicted, ymin = lower, ymax = upper)) +
  geom_line()+
  geom_ribbon(alpha = 0.2)+
  xlab(element_blank()) + 
  ylab("Predicted values of daily distance moved (m)") +
  theme_minimal()+
  facet_wrap(~period, scales = "free_x")
```

**Results:**
The best fitting model included period (pre or post reinforcement), date (linear and quadratic), the interaction between these, and individual as a random factor.

Residents moved significantly less distance post reinforcement and the trend was different. 

On average, residents moved 829m less in the post-reinforcement period (p < 0.001). The interaction of time and period was significant p < 0.001). 

**Interpretation:**
The residents changed their distance moved, perhaps to accommodate the reinforcers who could not immediately move as far. They slowly increased their distance moved to pre-reinforcement levels. 

## m7: Roost fidelty

Do residents change their distance between roosts after reinforcement?

```{r}
# read in data and filter to residents for reinforcement period
datam7 <- read.csv("results/daily_distance_between_roosts.csv") %>%
  # add metadata
  left_join(dplyr::select(metadata, c("id", "cohort"))) %>%
  # select only residents
  filter(cohort == "Resident") %>%
  # format dates as numeric
  mutate(date = as_date(date)) %>%
  # limit to reinforcement period
  filter(date %in% dates) %>%
  # add column for pre or post release
  mutate(period = factor(ifelse(date %in% pre_dates, 
                         "pre-reinforcement", "post-reinforcement"),
                         levels  = c("pre-reinforcement", "post-reinforcement")))

# create social group means
sum7 <- datam7 %>%
  group_by(date) %>%
  summarise(dist = mean(distance_previous),
            upper = dist + 1.96 * std.error(distance_previous),
            lower = dist - 1.96 * std.error(distance_previous)) %>%
  arrange(date)

# plot daily distance over time as period means
ggplot(sum7, aes(date, dist, ymin = lower, ymax = upper)) +
  geom_path() +
  geom_ribbon(alpha = 0.2) +
  xlab("Days post-reinforcement") + 
  ylab("Distance between consecutive roosts (m)") +
  theme_minimal() +
  scale_fill_viridis_d()+
  scale_colour_viridis_d()+
  geom_vline(aes(xintercept = as_date("2023-06-07")), colour = "purple")

# distribution of movement data
hist(datam7$distance_previous)
ggqqplot(datam7$distance_previous)

# correct left skew
hist(log1p(datam7$distance_previous))
ggqqplot(log1p(datam7$distance_previous))

# test difference pre and post reinforcement
m7 <- glmmTMB(log1p(distance_previous) ~ period * (scale(as.numeric(date)) + I(scale(as.numeric(date))^2)) + (1|id), 
              data = datam7,
              na.action = "na.fail")

# model selection
dm7 <- dredge(m7)
dm7

# parsimonious model where delta <2 and fewest predictors 
# in this case only one model (top ranked) had delta AICc <2
best7 <- get.models(dm7, delta<2)[[1]]

# check model
check_model(best7)

# summary
summary(best7)

# plot effects
plot_model(best7)
```

**Plot**

```{r}
# Generate prediction data only within valid date ranges
release_date <- as_date("2023-06-07")

pred_data_pre <- expand.grid(
  date = seq(min(datam7$date[datam7$period == "pre-reinforcement"]),
             release_date - 1, by = 1),
  period = "pre-reinforcement"
)

pred_data_post <- expand.grid(
  date = seq(release_date, max(datam7$date[datam7$period == "post-reinforcement"]), by = 1),
  period = "post-reinforcement"
)

# Combine and add necessary covariates (date2, id, etc.)
pred7 <- rbind(pred_data_pre, pred_data_post) %>%
  mutate(id = NA)

# Predict values using the valid dataset
values7 <- predict(best7, newdata = pred7, type = "response", se.fit = TRUE) %>%
  as.data.frame() 

# Add predictions to dataframe - back transform the log values using exponential
pred7 <- pred7 %>%
  mutate(
    predicted = expm1(values7$fit),
    lower = expm1(values7$fit - 1.96 * values7$se.fit),
    upper = expm1(values7$fit + 1.96 * values7$se.fit)
  ) %>%
  mutate(date = as_date(date))

# plot predictions
ggplot(pred7, aes(date, predicted, ymin = lower, ymax = upper)) +
  geom_line()+
  geom_ribbon(alpha = 0.2)+
  xlab(element_blank()) + 
  ylab("Predicted values of roost fidelity (m)") +
  theme_minimal()+
  facet_wrap(~period, scales = "free_x")
```

**Results:**
The best fitting model included period (pre or post reinforcement), date (linear and quadratic terms), the interaction between these, and individual as a random factor.

Residents moved significantly further between roosts immediately post-release, before settling. 

Initially after reinforcement, residents substantially increased their roost displacement (by about 132% from baseline. 116m + 50m), but this effect diminished over time according to the negative interaction term.

**Interpretation:**
The residents were disrupted by the reinforcers and had a short-term decrease in roost fidelity - perhaps to accommodate the move to the shared roost area. 

## m8: Release-site fidelity

Do residents change their distance from the release site after reinforcement?

```{r}
# read in data and filter to residents for reinforcement period
datam8 <- read.csv("results/daily_roost_distance_from_release.csv") %>%
 # add metadata
 left_join(dplyr::select(metadata, c("id", "cohort"))) %>%
 # select only residents
 filter(cohort == "Resident") %>%
 # format dates as numeric
 mutate(date = as_date(date)) %>%
 # limit to reinforcement period
 filter(date %in% dates) %>%
 # add column for pre or post release
 mutate(period = factor(ifelse(date %in% pre_dates, 
                        "pre-reinforcement", "post-reinforcement"),
                        levels  = c("pre-reinforcement", "post-reinforcement")))
# create social group means
sum8 <- datam8 %>%
 group_by(date) %>%
 summarise(dist = mean(dist_release),
           upper = dist + 1.96 * std.error(dist_release),
           lower = dist - 1.96 * std.error(dist_release)) %>%
 arrange(date)

# plot daily distance over time as period means
ggplot(sum8, aes(date, dist, ymin = lower, ymax = upper)) +
 geom_path() +
 geom_ribbon(alpha = 0.2) +
 xlab("Days post-reinforcement") + 
 ylab("Distance from release site (m)") +
 theme_minimal() +
 scale_fill_viridis_d()+
 scale_colour_viridis_d()+
 geom_vline(aes(xintercept = as_date("2023-06-07")), colour = "purple")

# distribution of movement data
hist(datam8$dist_release)
ggqqplot(datam8$dist_release)

# correct left skew - not perfect but okay
hist(log1p(datam8$dist_release))
ggqqplot(log1p(datam8$dist_release))

# test difference pre and post reinforcement
m8 <- glmmTMB(log1p(dist_release) ~ period * (scale(as.numeric(date)) + I(scale(as.numeric(date))^2)) + (1|id), 
             data = datam8,
             na.action = "na.fail")

# model selection
dm8 <- dredge(m8)
dm8

# parsimonious model where delta <2 and fewest predictors 
# in this case only one model (top ranked) had delta AICc <2
best8 <- get.models(dm8, delta<2)[[1]]

# check model
check_model(best8)

# summary
summary(best8)

# plot effects
plot_model(best8)
```

**Plot**

```{r}
# Generate prediction data only within valid date ranges
release_date <- as_date("2023-06-07")

pred_data_pre <- expand.grid(
 date = seq(min(datam8$date[datam8$period == "pre-reinforcement"]),
            release_date - 1, by = 1),
 period = "pre-reinforcement"
)

pred_data_post <- expand.grid(
 date = seq(release_date, max(datam8$date[datam8$period == "post-reinforcement"]), by = 1),
 period = "post-reinforcement"
)

# Combine and add necessary covariates (date2, id, etc.)
pred8 <- rbind(pred_data_pre, pred_data_post) %>%
 mutate(id = NA)

# Predict values using the valid dataset
values8 <- predict(best8, newdata = pred8, type = "response", se.fit = TRUE) %>%
 as.data.frame() 

# Add predictions to dataframe - back transform the log values using exponential
pred8 <- pred8 %>%
 mutate(
   predicted = expm1(values8$fit),
   lower = expm1(values8$fit - 1.96 * values8$se.fit),
   upper = expm1(values8$fit + 1.96 * values8$se.fit)
 ) %>%
 mutate(date = as_date(date))

# plot predictions
ggplot(pred8, aes(date, predicted, ymin = lower, ymax = upper)) +
 geom_line()+
 geom_ribbon(alpha = 0.2)+
 xlab(element_blank()) + 
 ylab("Predicted values of release fidelity (m)") +
 theme_minimal()+
 facet_wrap(~period, scales = "free_x")
```

**Results:**
The best fitting model included period (pre or post reinforcement), date (linear and quadratic), the interaction between these, and individual as a random factor. 

The main effect of period is not significant (p=0.679), meaning there wasn't an immediate change in residents' distance from the release site right after reinforcement.

The pre-reinforcement period shows strong negative linear (-1.26) and quadratic (-0.60) trends, indicating residents were already moving closer to the release site over time before reinforcement.

The significant interactions between period and time (both linear and quadratic) indicate the temporal pattern changed after reinforcement. Adding the interaction coefficients (0.38 for linear, 1.09 for quadratic) suggests a flattening or even reversal of the trend toward the release site.

**Interpretation:**
The residents were already moving back towards the release area, but slowed and stabilised with the addition of the reinforcers.

### Resident change map

I think it would be helpful to visualise their roost locations on a map.

```{r}
ggmap(map_z15)+
  # plot roosts colour by time
  geom_point(aes(longitude, latitude, colour = date),
             size = 2, data = datam8, inherit.aes = FALSE)+
  # add release location
  geom_point(aes(144.434323, -37.902374), 
             colour = "white", size = 5, shape = 13, inherit.aes = FALSE)+
  # add fence
  geom_spatvector(data = mtr, inherit.aes = FALSE, fill = NA, colour = "white",
                  linetype = "longdash")+
  # wrap by period
  facet_wrap(~period)+
  # theme options
  scale_colour_viridis_c(trans = "date", name = "2023")+
  theme_void()+
  scale_y_continuous(expand = expansion(mult = c(0, 0.01)))+
  ggplot2::theme(legend.position="bottom",
        legend.key.width = unit(4, 'cm'),
        strip.text = element_text(size = 15))
```

## m9: Home range size

Do residents change their home range size after reinforcement?

```{r}
# read in data and filter to residents for reinforcement period
datam9 <- read.csv("results/daily_hr90_area.csv") %>%
 # add metadata
 left_join(dplyr::select(metadata, c("id", "cohort"))) %>%
 # select only residents
 filter(cohort == "Resident") %>%
 # format dates as numeric
 mutate(date = as_date(date)) %>%
 # limit to reinforcement period
 filter(date %in% dates) %>%
 # add column for pre or post release
 mutate(period = factor(ifelse(date %in% pre_dates, 
                        "pre-reinforcement", "post-reinforcement"),
                        levels  = c("pre-reinforcement", "post-reinforcement")))
# create social group means
sum9 <- datam9 %>%
 group_by(date) %>%
 summarise(dist = mean(area),
           upper = dist + 1.96 * std.error(area),
           lower = dist - 1.96 * std.error(area)) %>%
 arrange(date)

# plot daily distance over time as period means
ggplot(sum9, aes(date, dist, ymin = lower, ymax = upper)) +
 geom_path() +
 geom_ribbon(alpha = 0.2) +
 xlab("Days post-reinforcement") + 
 ylab("Home range (90% KUD) area (ha)") +
 theme_minimal() +
 scale_fill_viridis_d()+
 scale_colour_viridis_d()+
 geom_vline(aes(xintercept = as_date("2023-06-07")), colour = "purple")

# distribution of movement data
hist(datam9$area)
ggqqplot(datam9$area)

# correct left skew
hist(log1p(datam9$area))
ggqqplot(log1p(datam9$area))

# test difference pre and post reinforcement
m9 <- glmmTMB(log1p(area) ~ period * (scale(as.numeric(date)) + I(scale(as.numeric(date))^2)) + (1|id), 
             data = datam9,
             na.action = "na.fail")

# model selection# moarea()del selection
dm9 <- dredge(m9)
dm9

# parsimonious model where delta <2 and fewest predictors 
# in this case two models had delta AICc <2 but the top ranked had fewer terms
best9 <- get.models(dm9, delta<2)[[1]]

# check model
check_model(best9)

# summary
summary(best9)

# plot effects
plot_model(best9)
```

**Plot**

```{r}
# Generate prediction data only within valid date ranges
release_date <- as_date("2023-06-07")

pred_data_pre <- expand.grid(
 date = seq(min(datam9$date[datam9$period == "pre-reinforcement"]),
            release_date - 1, by = 1),
 period = "pre-reinforcement"
)

pred_data_post <- expand.grid(
 date = seq(release_date, max(datam9$date[datam9$period == "post-reinforcement"]), by = 1),
 period = "post-reinforcement"
)

# Combine and add necessary covariates (date2, id, etc.)
pred9 <- rbind(pred_data_pre, pred_data_post) %>%
 mutate(id = NA)

# Predict values using the valid dataset
values9 <- predict(best9, newdata = pred9, type = "response", se.fit = TRUE) %>%
 as.data.frame() 

# Add predictions to dataframe - back transform the log values using exponential
pred9 <- pred9 %>%
 mutate(
   predicted = expm1(values9$fit),
   lower = expm1(values9$fit - 1.96 * values9$se.fit),
   upper = expm1(values9$fit + 1.96 * values9$se.fit)
 ) %>%
 mutate(date = as_date(date))

# plot predictions
ggplot(pred9, aes(date, predicted, ymin = lower, ymax = upper)) +
 geom_line()+
 geom_ribbon(alpha = 0.2)+
 xlab(element_blank()) + 
 ylab("Predicted values of home range size (ha)") +
 theme_minimal()+
 facet_wrap(~period, scales = "free_x")
```

**Results:**
The best fitting model included period (pre or post reinforcement), date (linear and quadratic), the interaction between these (but not a quadratic and period interaction), and individual as a random factor.

Immediately after reinforcement, residents reduced their home range sizes by about 35%.
However, the strong positive interaction term indicates this pattern reversed over time, with home ranges expanding again during the post-reinforcement period.

**Interpretation:**
Residents had already been increasing (perhaps a seasonal effect of less food going into winter) but temporarily declined post-reinforcement before increasing again. Not strong evidence for competition alone, and the contraction again in August suggests seasonal effects.

## Figure: resident stats

Multi-plot of predicted values for PRBM metrics for residents before and after reinforcement.

```{r}
# set default theme options for all plots
labels <- c(`pre-reinforcement` = "Pre reinforcement",
            `post-reinforcement` = "Post reinforcement")

theme <- function(){
  list(
  geom_line(),
  geom_ribbon(alpha = 0.2),
  xlab(element_blank()),
  theme_bw(),
  facet_wrap(~period, scales = "free_x",
             labeller = as_labeller(labels)),
  scale_x_date(date_breaks = "1 month", date_labels =  "%b"),
  ggplot2::theme(axis.title.y = element_text(hjust = 0.5, size = 10),
                 axis.title.x = element_text(size = 10),
                 panel.grid.major = element_blank(), 
                 panel.grid.minor = element_blank())
  )
}

# list of plots
g6 <- ggplot(pred6, aes(date, predicted, ymin = lower, ymax = upper)) +
  ylab("Daily distance moved (m)")+
  theme()

g7 <- ggplot(pred7, aes(date, predicted, ymin = lower, ymax = upper)) +
  ylab("Roost displacement (m)")+
  theme()

g8 <- ggplot(pred8, aes(date, predicted, ymin = lower, ymax = upper)) +
  ylab("Distance from release (m)")+
  theme()

g9 <- ggplot(pred9, aes(date, predicted, ymin = lower, ymax = upper)) +
   ylab("Home range area (ha)")+
  theme()

# multi plot 3x2
combined_plot <- (g6 + g7)  / (g8 + g9) + 
  plot_annotation(tag_levels = 'A')
combined_plot

# save 
ggsave("plots/resident_outcomes.png", dpi = 400, bg = 'white', 
       width = 20, height = 16, units = "cm")
```

## Table: resident models

Create model select and model effects tables for publication supp materials.

```{r}
# best models
tab_model(best6, best7, best8, best9, show.est = TRUE, show.se = TRUE, show.ci = FALSE,
          file = "results/m6-9_effects.xls")

# model selection table
ms2 <- mutate(as.data.frame(dm6), model = "distance daily") %>%
  rbind(mutate(as.data.frame(dm7), model = "roost displacement")) %>%
  rbind(mutate(as.data.frame(dm8), model = "release fidelity")) %>% 
  rbind(mutate(as.data.frame(dm9), model = "home range"))

write.csv(ms2, "results/m6-9_modelselection.csv", row.names = FALSE)
```

# Survival analysis

## Reinforcers and residents

Do reinforcers survive better than the residents? 

This is hard to answer because not tracked as long and some birds were subsequently moved to Orana (right censored data).

Attempt to answer this using Kaplan Meier Analysis. Start by looking at the overall survival probabilities for all birds.

```{r m6}
# Format data for Kaplan Meier Analysis - where death is TRUE i.e. 1
surv_data <- read_xlsx("data/survival.xlsx", sheet = 1) %>%
  clean_names

km <- with(surv_data, Surv(time, status))
  
# Fit a basic survival model
kmfit <- survfit(Surv(time, status) ~ 1, data = surv_data)

# Estimated survival probabilities
summary(kmfit, times = c(1, 10, 30, 55, 100, 365))

# plot
autoplot(kmfit)
```

The probability of survival to 1 year is 50% (CI: 34-75%). The probability of survival to 55 days (the study period) is 91% (CI: 83-100%).

Next we compare survival by cohorts.

```{r}
# Fit a survival model by cohort
kmfit_cohort <- survfit(Surv(time, status) ~ cohort, data = surv_data)

summary(kmfit_cohort, times = c(1,30,55))

# plot
autoplot(kmfit_cohort)

# Fit Cox Model
cox <- coxph(Surv(time, status) ~ cohort, data = surv_data)
summary(cox)
```

The probability of survival to 55 days for residents is 87% (CI: 71-100%) and for reinforcers is 95% (CI: 86-100%). So reinforcers are slightly more likely to survive, however this effect is not significant (p=0.549). There were two disease events (one in each cohort) that accounted for most of the early deaths. Potentially the stress of translocation caused these individuals to succumb to illness. 

## Reinforcers by social group

During the social analysis step we found that post-reinforcement there were two sub-groups to the community:

  1) a group with just reinforcers, and 
  2) a blended group of all remaining residents and half the reinforcers.
  
I hypothesise the group with the residents would survive better because of the enhanced potential for learning. 

Compare to 55 days (minimum common denominator deployment period for reinforcers).

```{r}
# social group membership
club <- c("Rowan", "Rory", "Fauna", "Zeus", "Rocky", "Sofi", "Loki", "Avery", "Maeve")

# Format data for Kaplan Meier Analysis - where death is TRUE i.e. 1
surv_data2 <- surv_data %>%
  # add column for membership to social group
  mutate(social = ifelse(identity %in% club, "exclusive", "mixed")) %>%
  # select only reinforcers
  filter(cohort == "Reinforcing")

# Fit a survival model by social group
kmfit_social <- survfit(Surv(time, status) ~ social, data = surv_data2)

summary(kmfit_social, times = c(1,30,55))

# plot
autoplot(kmfit_social)

# Fit Cox Model
cox <- coxph(Surv(time, status) ~ social, data = surv_data2)
summary(cox)
```

No difference in survival for reinforcers of different social memberships.